// Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  architectureDefinition: (
    where?: ArchitectureDefinitionWhereInput
  ) => Promise<boolean>;
  architectureTier: (where?: ArchitectureTierWhereInput) => Promise<boolean>;
  architectureType: (where?: ArchitectureTypeWhereInput) => Promise<boolean>;
  componentAttribute: (
    where?: ComponentAttributeWhereInput
  ) => Promise<boolean>;
  componentInstance: (where?: ComponentInstanceWhereInput) => Promise<boolean>;
  componentTemplate: (where?: ComponentTemplateWhereInput) => Promise<boolean>;
  customer: (where?: CustomerWhereInput) => Promise<boolean>;
  customerContact: (where?: CustomerContactWhereInput) => Promise<boolean>;
  environment: (where?: EnvironmentWhereInput) => Promise<boolean>;
  environmentTenant: (where?: EnvironmentTenantWhereInput) => Promise<boolean>;
  service: (where?: ServiceWhereInput) => Promise<boolean>;
  tenant: (where?: TenantWhereInput) => Promise<boolean>;
  tenantAttribute: (where?: TenantAttributeWhereInput) => Promise<boolean>;
  tenantRole: (where?: TenantRoleWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  architectureDefinition: (
    where: ArchitectureDefinitionWhereUniqueInput
  ) => ArchitectureDefinitionPromise;
  architectureDefinitions: (
    args?: {
      where?: ArchitectureDefinitionWhereInput;
      orderBy?: ArchitectureDefinitionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ArchitectureDefinition>;
  architectureDefinitionsConnection: (
    args?: {
      where?: ArchitectureDefinitionWhereInput;
      orderBy?: ArchitectureDefinitionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ArchitectureDefinitionConnectionPromise;
  architectureTier: (
    where: ArchitectureTierWhereUniqueInput
  ) => ArchitectureTierPromise;
  architectureTiers: (
    args?: {
      where?: ArchitectureTierWhereInput;
      orderBy?: ArchitectureTierOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ArchitectureTier>;
  architectureTiersConnection: (
    args?: {
      where?: ArchitectureTierWhereInput;
      orderBy?: ArchitectureTierOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ArchitectureTierConnectionPromise;
  architectureType: (
    where: ArchitectureTypeWhereUniqueInput
  ) => ArchitectureTypePromise;
  architectureTypes: (
    args?: {
      where?: ArchitectureTypeWhereInput;
      orderBy?: ArchitectureTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ArchitectureType>;
  architectureTypesConnection: (
    args?: {
      where?: ArchitectureTypeWhereInput;
      orderBy?: ArchitectureTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ArchitectureTypeConnectionPromise;
  componentAttribute: (
    where: ComponentAttributeWhereUniqueInput
  ) => ComponentAttributePromise;
  componentAttributes: (
    args?: {
      where?: ComponentAttributeWhereInput;
      orderBy?: ComponentAttributeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ComponentAttribute>;
  componentAttributesConnection: (
    args?: {
      where?: ComponentAttributeWhereInput;
      orderBy?: ComponentAttributeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ComponentAttributeConnectionPromise;
  componentInstance: (
    where: ComponentInstanceWhereUniqueInput
  ) => ComponentInstancePromise;
  componentInstances: (
    args?: {
      where?: ComponentInstanceWhereInput;
      orderBy?: ComponentInstanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ComponentInstance>;
  componentInstancesConnection: (
    args?: {
      where?: ComponentInstanceWhereInput;
      orderBy?: ComponentInstanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ComponentInstanceConnectionPromise;
  componentTemplate: (
    where: ComponentTemplateWhereUniqueInput
  ) => ComponentTemplatePromise;
  componentTemplates: (
    args?: {
      where?: ComponentTemplateWhereInput;
      orderBy?: ComponentTemplateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ComponentTemplate>;
  componentTemplatesConnection: (
    args?: {
      where?: ComponentTemplateWhereInput;
      orderBy?: ComponentTemplateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ComponentTemplateConnectionPromise;
  customer: (where: CustomerWhereUniqueInput) => CustomerPromise;
  customers: (
    args?: {
      where?: CustomerWhereInput;
      orderBy?: CustomerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Customer>;
  customersConnection: (
    args?: {
      where?: CustomerWhereInput;
      orderBy?: CustomerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CustomerConnectionPromise;
  customerContact: (
    where: CustomerContactWhereUniqueInput
  ) => CustomerContactPromise;
  customerContacts: (
    args?: {
      where?: CustomerContactWhereInput;
      orderBy?: CustomerContactOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CustomerContact>;
  customerContactsConnection: (
    args?: {
      where?: CustomerContactWhereInput;
      orderBy?: CustomerContactOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CustomerContactConnectionPromise;
  environment: (where: EnvironmentWhereUniqueInput) => EnvironmentPromise;
  environments: (
    args?: {
      where?: EnvironmentWhereInput;
      orderBy?: EnvironmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Environment>;
  environmentsConnection: (
    args?: {
      where?: EnvironmentWhereInput;
      orderBy?: EnvironmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => EnvironmentConnectionPromise;
  environmentTenant: (
    where: EnvironmentTenantWhereUniqueInput
  ) => EnvironmentTenantPromise;
  environmentTenants: (
    args?: {
      where?: EnvironmentTenantWhereInput;
      orderBy?: EnvironmentTenantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<EnvironmentTenant>;
  environmentTenantsConnection: (
    args?: {
      where?: EnvironmentTenantWhereInput;
      orderBy?: EnvironmentTenantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => EnvironmentTenantConnectionPromise;
  service: (where: ServiceWhereUniqueInput) => ServicePromise;
  services: (
    args?: {
      where?: ServiceWhereInput;
      orderBy?: ServiceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Service>;
  servicesConnection: (
    args?: {
      where?: ServiceWhereInput;
      orderBy?: ServiceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ServiceConnectionPromise;
  tenant: (where: TenantWhereUniqueInput) => TenantPromise;
  tenants: (
    args?: {
      where?: TenantWhereInput;
      orderBy?: TenantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Tenant>;
  tenantsConnection: (
    args?: {
      where?: TenantWhereInput;
      orderBy?: TenantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TenantConnectionPromise;
  tenantAttribute: (
    where: TenantAttributeWhereUniqueInput
  ) => TenantAttributePromise;
  tenantAttributes: (
    args?: {
      where?: TenantAttributeWhereInput;
      orderBy?: TenantAttributeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<TenantAttribute>;
  tenantAttributesConnection: (
    args?: {
      where?: TenantAttributeWhereInput;
      orderBy?: TenantAttributeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TenantAttributeConnectionPromise;
  tenantRole: (where: TenantRoleWhereUniqueInput) => TenantRolePromise;
  tenantRoles: (
    args?: {
      where?: TenantRoleWhereInput;
      orderBy?: TenantRoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<TenantRole>;
  tenantRolesConnection: (
    args?: {
      where?: TenantRoleWhereInput;
      orderBy?: TenantRoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TenantRoleConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createArchitectureDefinition: (
    data: ArchitectureDefinitionCreateInput
  ) => ArchitectureDefinitionPromise;
  updateArchitectureDefinition: (
    args: {
      data: ArchitectureDefinitionUpdateInput;
      where: ArchitectureDefinitionWhereUniqueInput;
    }
  ) => ArchitectureDefinitionPromise;
  updateManyArchitectureDefinitions: (
    args: {
      data: ArchitectureDefinitionUpdateManyMutationInput;
      where?: ArchitectureDefinitionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertArchitectureDefinition: (
    args: {
      where: ArchitectureDefinitionWhereUniqueInput;
      create: ArchitectureDefinitionCreateInput;
      update: ArchitectureDefinitionUpdateInput;
    }
  ) => ArchitectureDefinitionPromise;
  deleteArchitectureDefinition: (
    where: ArchitectureDefinitionWhereUniqueInput
  ) => ArchitectureDefinitionPromise;
  deleteManyArchitectureDefinitions: (
    where?: ArchitectureDefinitionWhereInput
  ) => BatchPayloadPromise;
  createArchitectureTier: (
    data: ArchitectureTierCreateInput
  ) => ArchitectureTierPromise;
  updateArchitectureTier: (
    args: {
      data: ArchitectureTierUpdateInput;
      where: ArchitectureTierWhereUniqueInput;
    }
  ) => ArchitectureTierPromise;
  updateManyArchitectureTiers: (
    args: {
      data: ArchitectureTierUpdateManyMutationInput;
      where?: ArchitectureTierWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertArchitectureTier: (
    args: {
      where: ArchitectureTierWhereUniqueInput;
      create: ArchitectureTierCreateInput;
      update: ArchitectureTierUpdateInput;
    }
  ) => ArchitectureTierPromise;
  deleteArchitectureTier: (
    where: ArchitectureTierWhereUniqueInput
  ) => ArchitectureTierPromise;
  deleteManyArchitectureTiers: (
    where?: ArchitectureTierWhereInput
  ) => BatchPayloadPromise;
  createArchitectureType: (
    data: ArchitectureTypeCreateInput
  ) => ArchitectureTypePromise;
  updateArchitectureType: (
    args: {
      data: ArchitectureTypeUpdateInput;
      where: ArchitectureTypeWhereUniqueInput;
    }
  ) => ArchitectureTypePromise;
  updateManyArchitectureTypes: (
    args: {
      data: ArchitectureTypeUpdateManyMutationInput;
      where?: ArchitectureTypeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertArchitectureType: (
    args: {
      where: ArchitectureTypeWhereUniqueInput;
      create: ArchitectureTypeCreateInput;
      update: ArchitectureTypeUpdateInput;
    }
  ) => ArchitectureTypePromise;
  deleteArchitectureType: (
    where: ArchitectureTypeWhereUniqueInput
  ) => ArchitectureTypePromise;
  deleteManyArchitectureTypes: (
    where?: ArchitectureTypeWhereInput
  ) => BatchPayloadPromise;
  createComponentAttribute: (
    data: ComponentAttributeCreateInput
  ) => ComponentAttributePromise;
  updateComponentAttribute: (
    args: {
      data: ComponentAttributeUpdateInput;
      where: ComponentAttributeWhereUniqueInput;
    }
  ) => ComponentAttributePromise;
  updateManyComponentAttributes: (
    args: {
      data: ComponentAttributeUpdateManyMutationInput;
      where?: ComponentAttributeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertComponentAttribute: (
    args: {
      where: ComponentAttributeWhereUniqueInput;
      create: ComponentAttributeCreateInput;
      update: ComponentAttributeUpdateInput;
    }
  ) => ComponentAttributePromise;
  deleteComponentAttribute: (
    where: ComponentAttributeWhereUniqueInput
  ) => ComponentAttributePromise;
  deleteManyComponentAttributes: (
    where?: ComponentAttributeWhereInput
  ) => BatchPayloadPromise;
  createComponentInstance: (
    data: ComponentInstanceCreateInput
  ) => ComponentInstancePromise;
  updateComponentInstance: (
    args: {
      data: ComponentInstanceUpdateInput;
      where: ComponentInstanceWhereUniqueInput;
    }
  ) => ComponentInstancePromise;
  updateManyComponentInstances: (
    args: {
      data: ComponentInstanceUpdateManyMutationInput;
      where?: ComponentInstanceWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertComponentInstance: (
    args: {
      where: ComponentInstanceWhereUniqueInput;
      create: ComponentInstanceCreateInput;
      update: ComponentInstanceUpdateInput;
    }
  ) => ComponentInstancePromise;
  deleteComponentInstance: (
    where: ComponentInstanceWhereUniqueInput
  ) => ComponentInstancePromise;
  deleteManyComponentInstances: (
    where?: ComponentInstanceWhereInput
  ) => BatchPayloadPromise;
  createComponentTemplate: (
    data: ComponentTemplateCreateInput
  ) => ComponentTemplatePromise;
  updateComponentTemplate: (
    args: {
      data: ComponentTemplateUpdateInput;
      where: ComponentTemplateWhereUniqueInput;
    }
  ) => ComponentTemplatePromise;
  updateManyComponentTemplates: (
    args: {
      data: ComponentTemplateUpdateManyMutationInput;
      where?: ComponentTemplateWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertComponentTemplate: (
    args: {
      where: ComponentTemplateWhereUniqueInput;
      create: ComponentTemplateCreateInput;
      update: ComponentTemplateUpdateInput;
    }
  ) => ComponentTemplatePromise;
  deleteComponentTemplate: (
    where: ComponentTemplateWhereUniqueInput
  ) => ComponentTemplatePromise;
  deleteManyComponentTemplates: (
    where?: ComponentTemplateWhereInput
  ) => BatchPayloadPromise;
  createCustomer: (data: CustomerCreateInput) => CustomerPromise;
  updateCustomer: (
    args: { data: CustomerUpdateInput; where: CustomerWhereUniqueInput }
  ) => CustomerPromise;
  updateManyCustomers: (
    args: { data: CustomerUpdateManyMutationInput; where?: CustomerWhereInput }
  ) => BatchPayloadPromise;
  upsertCustomer: (
    args: {
      where: CustomerWhereUniqueInput;
      create: CustomerCreateInput;
      update: CustomerUpdateInput;
    }
  ) => CustomerPromise;
  deleteCustomer: (where: CustomerWhereUniqueInput) => CustomerPromise;
  deleteManyCustomers: (where?: CustomerWhereInput) => BatchPayloadPromise;
  createCustomerContact: (
    data: CustomerContactCreateInput
  ) => CustomerContactPromise;
  updateCustomerContact: (
    args: {
      data: CustomerContactUpdateInput;
      where: CustomerContactWhereUniqueInput;
    }
  ) => CustomerContactPromise;
  updateManyCustomerContacts: (
    args: {
      data: CustomerContactUpdateManyMutationInput;
      where?: CustomerContactWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCustomerContact: (
    args: {
      where: CustomerContactWhereUniqueInput;
      create: CustomerContactCreateInput;
      update: CustomerContactUpdateInput;
    }
  ) => CustomerContactPromise;
  deleteCustomerContact: (
    where: CustomerContactWhereUniqueInput
  ) => CustomerContactPromise;
  deleteManyCustomerContacts: (
    where?: CustomerContactWhereInput
  ) => BatchPayloadPromise;
  createEnvironment: (data: EnvironmentCreateInput) => EnvironmentPromise;
  updateEnvironment: (
    args: { data: EnvironmentUpdateInput; where: EnvironmentWhereUniqueInput }
  ) => EnvironmentPromise;
  updateManyEnvironments: (
    args: {
      data: EnvironmentUpdateManyMutationInput;
      where?: EnvironmentWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertEnvironment: (
    args: {
      where: EnvironmentWhereUniqueInput;
      create: EnvironmentCreateInput;
      update: EnvironmentUpdateInput;
    }
  ) => EnvironmentPromise;
  deleteEnvironment: (where: EnvironmentWhereUniqueInput) => EnvironmentPromise;
  deleteManyEnvironments: (
    where?: EnvironmentWhereInput
  ) => BatchPayloadPromise;
  createEnvironmentTenant: (
    data: EnvironmentTenantCreateInput
  ) => EnvironmentTenantPromise;
  updateEnvironmentTenant: (
    args: {
      data: EnvironmentTenantUpdateInput;
      where: EnvironmentTenantWhereUniqueInput;
    }
  ) => EnvironmentTenantPromise;
  updateManyEnvironmentTenants: (
    args: {
      data: EnvironmentTenantUpdateManyMutationInput;
      where?: EnvironmentTenantWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertEnvironmentTenant: (
    args: {
      where: EnvironmentTenantWhereUniqueInput;
      create: EnvironmentTenantCreateInput;
      update: EnvironmentTenantUpdateInput;
    }
  ) => EnvironmentTenantPromise;
  deleteEnvironmentTenant: (
    where: EnvironmentTenantWhereUniqueInput
  ) => EnvironmentTenantPromise;
  deleteManyEnvironmentTenants: (
    where?: EnvironmentTenantWhereInput
  ) => BatchPayloadPromise;
  createService: (data: ServiceCreateInput) => ServicePromise;
  updateService: (
    args: { data: ServiceUpdateInput; where: ServiceWhereUniqueInput }
  ) => ServicePromise;
  updateManyServices: (
    args: { data: ServiceUpdateManyMutationInput; where?: ServiceWhereInput }
  ) => BatchPayloadPromise;
  upsertService: (
    args: {
      where: ServiceWhereUniqueInput;
      create: ServiceCreateInput;
      update: ServiceUpdateInput;
    }
  ) => ServicePromise;
  deleteService: (where: ServiceWhereUniqueInput) => ServicePromise;
  deleteManyServices: (where?: ServiceWhereInput) => BatchPayloadPromise;
  createTenant: (data: TenantCreateInput) => TenantPromise;
  updateTenant: (
    args: { data: TenantUpdateInput; where: TenantWhereUniqueInput }
  ) => TenantPromise;
  updateManyTenants: (
    args: { data: TenantUpdateManyMutationInput; where?: TenantWhereInput }
  ) => BatchPayloadPromise;
  upsertTenant: (
    args: {
      where: TenantWhereUniqueInput;
      create: TenantCreateInput;
      update: TenantUpdateInput;
    }
  ) => TenantPromise;
  deleteTenant: (where: TenantWhereUniqueInput) => TenantPromise;
  deleteManyTenants: (where?: TenantWhereInput) => BatchPayloadPromise;
  createTenantAttribute: (
    data: TenantAttributeCreateInput
  ) => TenantAttributePromise;
  updateTenantAttribute: (
    args: {
      data: TenantAttributeUpdateInput;
      where: TenantAttributeWhereUniqueInput;
    }
  ) => TenantAttributePromise;
  updateManyTenantAttributes: (
    args: {
      data: TenantAttributeUpdateManyMutationInput;
      where?: TenantAttributeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertTenantAttribute: (
    args: {
      where: TenantAttributeWhereUniqueInput;
      create: TenantAttributeCreateInput;
      update: TenantAttributeUpdateInput;
    }
  ) => TenantAttributePromise;
  deleteTenantAttribute: (
    where: TenantAttributeWhereUniqueInput
  ) => TenantAttributePromise;
  deleteManyTenantAttributes: (
    where?: TenantAttributeWhereInput
  ) => BatchPayloadPromise;
  createTenantRole: (data: TenantRoleCreateInput) => TenantRolePromise;
  updateTenantRole: (
    args: { data: TenantRoleUpdateInput; where: TenantRoleWhereUniqueInput }
  ) => TenantRolePromise;
  updateManyTenantRoles: (
    args: {
      data: TenantRoleUpdateManyMutationInput;
      where?: TenantRoleWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertTenantRole: (
    args: {
      where: TenantRoleWhereUniqueInput;
      create: TenantRoleCreateInput;
      update: TenantRoleUpdateInput;
    }
  ) => TenantRolePromise;
  deleteTenantRole: (where: TenantRoleWhereUniqueInput) => TenantRolePromise;
  deleteManyTenantRoles: (where?: TenantRoleWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  architectureDefinition: (
    where?: ArchitectureDefinitionSubscriptionWhereInput
  ) => ArchitectureDefinitionSubscriptionPayloadSubscription;
  architectureTier: (
    where?: ArchitectureTierSubscriptionWhereInput
  ) => ArchitectureTierSubscriptionPayloadSubscription;
  architectureType: (
    where?: ArchitectureTypeSubscriptionWhereInput
  ) => ArchitectureTypeSubscriptionPayloadSubscription;
  componentAttribute: (
    where?: ComponentAttributeSubscriptionWhereInput
  ) => ComponentAttributeSubscriptionPayloadSubscription;
  componentInstance: (
    where?: ComponentInstanceSubscriptionWhereInput
  ) => ComponentInstanceSubscriptionPayloadSubscription;
  componentTemplate: (
    where?: ComponentTemplateSubscriptionWhereInput
  ) => ComponentTemplateSubscriptionPayloadSubscription;
  customer: (
    where?: CustomerSubscriptionWhereInput
  ) => CustomerSubscriptionPayloadSubscription;
  customerContact: (
    where?: CustomerContactSubscriptionWhereInput
  ) => CustomerContactSubscriptionPayloadSubscription;
  environment: (
    where?: EnvironmentSubscriptionWhereInput
  ) => EnvironmentSubscriptionPayloadSubscription;
  environmentTenant: (
    where?: EnvironmentTenantSubscriptionWhereInput
  ) => EnvironmentTenantSubscriptionPayloadSubscription;
  service: (
    where?: ServiceSubscriptionWhereInput
  ) => ServiceSubscriptionPayloadSubscription;
  tenant: (
    where?: TenantSubscriptionWhereInput
  ) => TenantSubscriptionPayloadSubscription;
  tenantAttribute: (
    where?: TenantAttributeSubscriptionWhereInput
  ) => TenantAttributeSubscriptionPayloadSubscription;
  tenantRole: (
    where?: TenantRoleSubscriptionWhereInput
  ) => TenantRoleSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ComponentInstanceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC";

export type ArchitectureTierOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "priority_ASC"
  | "priority_DESC";

export type TenantAttributeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "parameter_ASC"
  | "parameter_DESC"
  | "value_ASC"
  | "value_DESC";

export type TenantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CustomerContactOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "sms_ASC"
  | "sms_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EnvironmentTenantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "code_ASC"
  | "code_DESC"
  | "class_ASC"
  | "class_DESC"
  | "primaryContactEmail_ASC"
  | "primaryContactEmail_DESC"
  | "tenantCreationDate_ASC"
  | "tenantCreationDate_DESC";

export type CustomerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "code_ASC"
  | "code_DESC"
  | "status_ASC"
  | "status_DESC";

export type ArchitectureTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC";

export type ServiceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "code_ASC"
  | "code_DESC"
  | "description_ASC"
  | "description_DESC"
  | "status_ASC"
  | "status_DESC"
  | "type_ASC"
  | "type_DESC"
  | "version_ASC"
  | "version_DESC"
  | "canBeRemoved_ASC"
  | "canBeRemoved_DESC";

export type EnvironmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "code_ASC"
  | "code_DESC"
  | "description_ASC"
  | "description_DESC"
  | "region_ASC"
  | "region_DESC"
  | "classification_ASC"
  | "classification_DESC";

export type ArchitectureDefinitionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "code_ASC"
  | "code_DESC"
  | "description_ASC"
  | "description_DESC";

export type ComponentAttributeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "parameter_ASC"
  | "parameter_DESC"
  | "value_ASC"
  | "value_DESC";

export type Role = "MASTER_ADMIN" | "TENANT_ADMIN" | "TEAM_MEMBER";

export type TenantRoleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "role_ASC"
  | "role_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ComponentTemplateOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "code_ASC"
  | "code_DESC";

export interface EnvironmentUpdateWithoutServiceDataInput {
  name?: String;
  code?: String;
  description?: String;
  region?: String;
  classification?: String;
  tenants?: EnvironmentTenantUpdateManyWithoutEnvironmentInput;
  components?: ComponentInstanceUpdateManyWithoutEnvironmentInput;
}

export type ArchitectureDefinitionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
  code?: String;
}>;

export interface ArchitectureTierUpdateManyMutationInput {
  name?: String;
  priority?: Int;
}

export interface CustomerContactUpdateManyMutationInput {
  name?: String;
  email?: String;
  phone?: String;
  sms?: String;
}

export interface ArchitectureTypeUpdateInput {
  name?: String;
}

export interface CustomerContactUpsertWithWhereUniqueWithoutCustomerInput {
  where: CustomerContactWhereUniqueInput;
  update: CustomerContactUpdateWithoutCustomerDataInput;
  create: CustomerContactCreateWithoutCustomerInput;
}

export interface ArchitectureTypeUpdateManyMutationInput {
  name?: String;
}

export interface TenantRoleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TenantRoleWhereInput;
  AND?: TenantRoleSubscriptionWhereInput[] | TenantRoleSubscriptionWhereInput;
  OR?: TenantRoleSubscriptionWhereInput[] | TenantRoleSubscriptionWhereInput;
  NOT?: TenantRoleSubscriptionWhereInput[] | TenantRoleSubscriptionWhereInput;
}

export interface ComponentAttributeCreateInput {
  parameter: String;
  value: String;
  component: ComponentInstanceCreateOneWithoutAttributesInput;
}

export interface TenantSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TenantWhereInput;
  AND?: TenantSubscriptionWhereInput[] | TenantSubscriptionWhereInput;
  OR?: TenantSubscriptionWhereInput[] | TenantSubscriptionWhereInput;
  NOT?: TenantSubscriptionWhereInput[] | TenantSubscriptionWhereInput;
}

export interface ComponentInstanceCreateOneWithoutAttributesInput {
  create?: ComponentInstanceCreateWithoutAttributesInput;
  connect?: ComponentInstanceWhereUniqueInput;
}

export interface ServiceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ServiceWhereInput;
  AND?: ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput;
  OR?: ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput;
  NOT?: ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput;
}

export interface ComponentInstanceCreateWithoutAttributesInput {
  name: String;
  environment: EnvironmentCreateOneWithoutComponentsInput;
  component: ComponentTemplateCreateOneInput;
}

export interface EnvironmentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EnvironmentWhereInput;
  AND?: EnvironmentSubscriptionWhereInput[] | EnvironmentSubscriptionWhereInput;
  OR?: EnvironmentSubscriptionWhereInput[] | EnvironmentSubscriptionWhereInput;
  NOT?: EnvironmentSubscriptionWhereInput[] | EnvironmentSubscriptionWhereInput;
}

export interface EnvironmentCreateOneWithoutComponentsInput {
  create?: EnvironmentCreateWithoutComponentsInput;
  connect?: EnvironmentWhereUniqueInput;
}

export type ComponentAttributeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  parameter?: String;
}>;

export interface EnvironmentCreateWithoutComponentsInput {
  name: String;
  code: String;
  description?: String;
  region?: String;
  classification: String;
  service: ServiceCreateOneWithoutEnvironmentsInput;
  tenants?: EnvironmentTenantCreateManyWithoutEnvironmentInput;
}

export interface ComponentTemplateSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ComponentTemplateWhereInput;
  AND?:
    | ComponentTemplateSubscriptionWhereInput[]
    | ComponentTemplateSubscriptionWhereInput;
  OR?:
    | ComponentTemplateSubscriptionWhereInput[]
    | ComponentTemplateSubscriptionWhereInput;
  NOT?:
    | ComponentTemplateSubscriptionWhereInput[]
    | ComponentTemplateSubscriptionWhereInput;
}

export interface ServiceCreateOneWithoutEnvironmentsInput {
  create?: ServiceCreateWithoutEnvironmentsInput;
  connect?: ServiceWhereUniqueInput;
}

export interface ComponentAttributeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ComponentAttributeWhereInput;
  AND?:
    | ComponentAttributeSubscriptionWhereInput[]
    | ComponentAttributeSubscriptionWhereInput;
  OR?:
    | ComponentAttributeSubscriptionWhereInput[]
    | ComponentAttributeSubscriptionWhereInput;
  NOT?:
    | ComponentAttributeSubscriptionWhereInput[]
    | ComponentAttributeSubscriptionWhereInput;
}

export interface ServiceCreateWithoutEnvironmentsInput {
  name: String;
  code: String;
  description?: String;
  status: String;
  type: String;
  version?: String;
  canBeRemoved?: Boolean;
  dependentServices?: ServiceCreateManyInput;
}

export interface EnvironmentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  region?: String;
  region_not?: String;
  region_in?: String[] | String;
  region_not_in?: String[] | String;
  region_lt?: String;
  region_lte?: String;
  region_gt?: String;
  region_gte?: String;
  region_contains?: String;
  region_not_contains?: String;
  region_starts_with?: String;
  region_not_starts_with?: String;
  region_ends_with?: String;
  region_not_ends_with?: String;
  classification?: String;
  classification_not?: String;
  classification_in?: String[] | String;
  classification_not_in?: String[] | String;
  classification_lt?: String;
  classification_lte?: String;
  classification_gt?: String;
  classification_gte?: String;
  classification_contains?: String;
  classification_not_contains?: String;
  classification_starts_with?: String;
  classification_not_starts_with?: String;
  classification_ends_with?: String;
  classification_not_ends_with?: String;
  service?: ServiceWhereInput;
  tenants_every?: EnvironmentTenantWhereInput;
  tenants_some?: EnvironmentTenantWhereInput;
  tenants_none?: EnvironmentTenantWhereInput;
  components_every?: ComponentInstanceWhereInput;
  components_some?: ComponentInstanceWhereInput;
  components_none?: ComponentInstanceWhereInput;
  AND?: EnvironmentWhereInput[] | EnvironmentWhereInput;
  OR?: EnvironmentWhereInput[] | EnvironmentWhereInput;
  NOT?: EnvironmentWhereInput[] | EnvironmentWhereInput;
}

export interface ServiceCreateManyInput {
  create?: ServiceCreateInput[] | ServiceCreateInput;
  connect?: ServiceWhereUniqueInput[] | ServiceWhereUniqueInput;
}

export interface CustomerWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  status?: String;
  status_not?: String;
  status_in?: String[] | String;
  status_not_in?: String[] | String;
  status_lt?: String;
  status_lte?: String;
  status_gt?: String;
  status_gte?: String;
  status_contains?: String;
  status_not_contains?: String;
  status_starts_with?: String;
  status_not_starts_with?: String;
  status_ends_with?: String;
  status_not_ends_with?: String;
  contacts_every?: CustomerContactWhereInput;
  contacts_some?: CustomerContactWhereInput;
  contacts_none?: CustomerContactWhereInput;
  tenants_every?: EnvironmentTenantWhereInput;
  tenants_some?: EnvironmentTenantWhereInput;
  tenants_none?: EnvironmentTenantWhereInput;
  AND?: CustomerWhereInput[] | CustomerWhereInput;
  OR?: CustomerWhereInput[] | CustomerWhereInput;
  NOT?: CustomerWhereInput[] | CustomerWhereInput;
}

export interface ServiceCreateInput {
  name: String;
  code: String;
  description?: String;
  status: String;
  type: String;
  version?: String;
  canBeRemoved?: Boolean;
  dependentServices?: ServiceCreateManyInput;
  environments?: EnvironmentCreateManyWithoutServiceInput;
}

export interface TenantAttributeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  parameter?: String;
  parameter_not?: String;
  parameter_in?: String[] | String;
  parameter_not_in?: String[] | String;
  parameter_lt?: String;
  parameter_lte?: String;
  parameter_gt?: String;
  parameter_gte?: String;
  parameter_contains?: String;
  parameter_not_contains?: String;
  parameter_starts_with?: String;
  parameter_not_starts_with?: String;
  parameter_ends_with?: String;
  parameter_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  tenant?: EnvironmentTenantWhereInput;
  AND?: TenantAttributeWhereInput[] | TenantAttributeWhereInput;
  OR?: TenantAttributeWhereInput[] | TenantAttributeWhereInput;
  NOT?: TenantAttributeWhereInput[] | TenantAttributeWhereInput;
}

export interface EnvironmentCreateManyWithoutServiceInput {
  create?:
    | EnvironmentCreateWithoutServiceInput[]
    | EnvironmentCreateWithoutServiceInput;
  connect?: EnvironmentWhereUniqueInput[] | EnvironmentWhereUniqueInput;
}

export interface ComponentAttributeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  parameter?: String;
  parameter_not?: String;
  parameter_in?: String[] | String;
  parameter_not_in?: String[] | String;
  parameter_lt?: String;
  parameter_lte?: String;
  parameter_gt?: String;
  parameter_gte?: String;
  parameter_contains?: String;
  parameter_not_contains?: String;
  parameter_starts_with?: String;
  parameter_not_starts_with?: String;
  parameter_ends_with?: String;
  parameter_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  component?: ComponentInstanceWhereInput;
  AND?: ComponentAttributeWhereInput[] | ComponentAttributeWhereInput;
  OR?: ComponentAttributeWhereInput[] | ComponentAttributeWhereInput;
  NOT?: ComponentAttributeWhereInput[] | ComponentAttributeWhereInput;
}

export interface EnvironmentCreateWithoutServiceInput {
  name: String;
  code: String;
  description?: String;
  region?: String;
  classification: String;
  tenants?: EnvironmentTenantCreateManyWithoutEnvironmentInput;
  components?: ComponentInstanceCreateManyWithoutEnvironmentInput;
}

export interface ArchitectureTierSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ArchitectureTierWhereInput;
  AND?:
    | ArchitectureTierSubscriptionWhereInput[]
    | ArchitectureTierSubscriptionWhereInput;
  OR?:
    | ArchitectureTierSubscriptionWhereInput[]
    | ArchitectureTierSubscriptionWhereInput;
  NOT?:
    | ArchitectureTierSubscriptionWhereInput[]
    | ArchitectureTierSubscriptionWhereInput;
}

export interface EnvironmentTenantCreateManyWithoutEnvironmentInput {
  create?:
    | EnvironmentTenantCreateWithoutEnvironmentInput[]
    | EnvironmentTenantCreateWithoutEnvironmentInput;
  connect?:
    | EnvironmentTenantWhereUniqueInput[]
    | EnvironmentTenantWhereUniqueInput;
}

export interface ArchitectureDefinitionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ArchitectureDefinitionWhereInput;
  AND?:
    | ArchitectureDefinitionSubscriptionWhereInput[]
    | ArchitectureDefinitionSubscriptionWhereInput;
  OR?:
    | ArchitectureDefinitionSubscriptionWhereInput[]
    | ArchitectureDefinitionSubscriptionWhereInput;
  NOT?:
    | ArchitectureDefinitionSubscriptionWhereInput[]
    | ArchitectureDefinitionSubscriptionWhereInput;
}

export interface EnvironmentTenantCreateWithoutEnvironmentInput {
  name: String;
  code: String;
  class?: String;
  primaryContactEmail?: String;
  tenantCreationDate?: DateTimeInput;
  customer: CustomerCreateOneWithoutTenantsInput;
  attributes?: TenantAttributeCreateManyWithoutTenantInput;
}

export interface ArchitectureDefinitionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  type?: ArchitectureTypeWhereInput;
  components_every?: ComponentTemplateWhereInput;
  components_some?: ComponentTemplateWhereInput;
  components_none?: ComponentTemplateWhereInput;
  AND?: ArchitectureDefinitionWhereInput[] | ArchitectureDefinitionWhereInput;
  OR?: ArchitectureDefinitionWhereInput[] | ArchitectureDefinitionWhereInput;
  NOT?: ArchitectureDefinitionWhereInput[] | ArchitectureDefinitionWhereInput;
}

export interface CustomerCreateOneWithoutTenantsInput {
  create?: CustomerCreateWithoutTenantsInput;
  connect?: CustomerWhereUniqueInput;
}

export interface TenantRoleUpdateManyMutationInput {
  role?: Role;
}

export interface CustomerCreateWithoutTenantsInput {
  name: String;
  code: String;
  status?: String;
  contacts?: CustomerContactCreateManyWithoutCustomerInput;
}

export interface UserUpdateWithoutTenantRolesDataInput {
  name?: String;
  email?: String;
  password?: String;
}

export interface CustomerContactCreateManyWithoutCustomerInput {
  create?:
    | CustomerContactCreateWithoutCustomerInput[]
    | CustomerContactCreateWithoutCustomerInput;
  connect?: CustomerContactWhereUniqueInput[] | CustomerContactWhereUniqueInput;
}

export interface TenantRoleUpdateInput {
  user?: UserUpdateOneRequiredWithoutTenantRolesInput;
  tenant?: TenantUpdateOneRequiredInput;
  role?: Role;
}

export interface CustomerContactCreateWithoutCustomerInput {
  name: String;
  email: String;
  phone?: String;
  sms?: String;
}

export interface UserCreateOneWithoutTenantRolesInput {
  create?: UserCreateWithoutTenantRolesInput;
  connect?: UserWhereUniqueInput;
}

export interface TenantAttributeCreateManyWithoutTenantInput {
  create?:
    | TenantAttributeCreateWithoutTenantInput[]
    | TenantAttributeCreateWithoutTenantInput;
  connect?: TenantAttributeWhereUniqueInput[] | TenantAttributeWhereUniqueInput;
}

export interface TenantRoleCreateInput {
  user: UserCreateOneWithoutTenantRolesInput;
  tenant: TenantCreateOneInput;
  role: Role;
}

export interface TenantAttributeCreateWithoutTenantInput {
  parameter: String;
  value: String;
}

export interface EnvironmentTenantUpsertWithoutAttributesInput {
  update: EnvironmentTenantUpdateWithoutAttributesDataInput;
  create: EnvironmentTenantCreateWithoutAttributesInput;
}

export interface ComponentInstanceCreateManyWithoutEnvironmentInput {
  create?:
    | ComponentInstanceCreateWithoutEnvironmentInput[]
    | ComponentInstanceCreateWithoutEnvironmentInput;
  connect?:
    | ComponentInstanceWhereUniqueInput[]
    | ComponentInstanceWhereUniqueInput;
}

export interface EnvironmentTenantUpdateWithoutAttributesDataInput {
  name?: String;
  code?: String;
  class?: String;
  primaryContactEmail?: String;
  tenantCreationDate?: DateTimeInput;
  customer?: CustomerUpdateOneRequiredWithoutTenantsInput;
  environment?: EnvironmentUpdateOneRequiredWithoutTenantsInput;
}

export interface ComponentInstanceCreateWithoutEnvironmentInput {
  name: String;
  component: ComponentTemplateCreateOneInput;
  attributes?: ComponentAttributeCreateManyWithoutComponentInput;
}

export interface TenantAttributeUpdateInput {
  parameter?: String;
  value?: String;
  tenant?: EnvironmentTenantUpdateOneRequiredWithoutAttributesInput;
}

export interface ComponentTemplateCreateOneInput {
  create?: ComponentTemplateCreateInput;
  connect?: ComponentTemplateWhereUniqueInput;
}

export interface ArchitectureTierWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  priority?: Int;
  priority_not?: Int;
  priority_in?: Int[] | Int;
  priority_not_in?: Int[] | Int;
  priority_lt?: Int;
  priority_lte?: Int;
  priority_gt?: Int;
  priority_gte?: Int;
  AND?: ArchitectureTierWhereInput[] | ArchitectureTierWhereInput;
  OR?: ArchitectureTierWhereInput[] | ArchitectureTierWhereInput;
  NOT?: ArchitectureTierWhereInput[] | ArchitectureTierWhereInput;
}

export interface ComponentAttributeCreateManyWithoutComponentInput {
  create?:
    | ComponentAttributeCreateWithoutComponentInput[]
    | ComponentAttributeCreateWithoutComponentInput;
  connect?:
    | ComponentAttributeWhereUniqueInput[]
    | ComponentAttributeWhereUniqueInput;
}

export interface EnvironmentTenantCreateOneWithoutAttributesInput {
  create?: EnvironmentTenantCreateWithoutAttributesInput;
  connect?: EnvironmentTenantWhereUniqueInput;
}

export interface ComponentAttributeCreateWithoutComponentInput {
  parameter: String;
  value: String;
}

export type CustomerContactWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface ComponentAttributeUpdateInput {
  parameter?: String;
  value?: String;
  component?: ComponentInstanceUpdateOneRequiredWithoutAttributesInput;
}

export interface UserUpdateManyDataInput {
  name?: String;
  email?: String;
  password?: String;
}

export interface ComponentInstanceUpdateOneRequiredWithoutAttributesInput {
  create?: ComponentInstanceCreateWithoutAttributesInput;
  update?: ComponentInstanceUpdateWithoutAttributesDataInput;
  upsert?: ComponentInstanceUpsertWithoutAttributesInput;
  connect?: ComponentInstanceWhereUniqueInput;
}

export type EnvironmentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  code?: String;
}>;

export interface ComponentInstanceUpdateWithoutAttributesDataInput {
  name?: String;
  environment?: EnvironmentUpdateOneRequiredWithoutComponentsInput;
  component?: ComponentTemplateUpdateOneRequiredInput;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface EnvironmentUpdateOneRequiredWithoutComponentsInput {
  create?: EnvironmentCreateWithoutComponentsInput;
  update?: EnvironmentUpdateWithoutComponentsDataInput;
  upsert?: EnvironmentUpsertWithoutComponentsInput;
  connect?: EnvironmentWhereUniqueInput;
}

export type EnvironmentTenantWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  code?: String;
}>;

export interface EnvironmentUpdateWithoutComponentsDataInput {
  name?: String;
  code?: String;
  description?: String;
  region?: String;
  classification?: String;
  service?: ServiceUpdateOneRequiredWithoutEnvironmentsInput;
  tenants?: EnvironmentTenantUpdateManyWithoutEnvironmentInput;
}

export interface TenantRoleScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  role?: Role;
  role_not?: Role;
  role_in?: Role[] | Role;
  role_not_in?: Role[] | Role;
  AND?: TenantRoleScalarWhereInput[] | TenantRoleScalarWhereInput;
  OR?: TenantRoleScalarWhereInput[] | TenantRoleScalarWhereInput;
  NOT?: TenantRoleScalarWhereInput[] | TenantRoleScalarWhereInput;
}

export interface ServiceUpdateOneRequiredWithoutEnvironmentsInput {
  create?: ServiceCreateWithoutEnvironmentsInput;
  update?: ServiceUpdateWithoutEnvironmentsDataInput;
  upsert?: ServiceUpsertWithoutEnvironmentsInput;
  connect?: ServiceWhereUniqueInput;
}

export type ServiceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  code?: String;
}>;

export interface ServiceUpdateWithoutEnvironmentsDataInput {
  name?: String;
  code?: String;
  description?: String;
  status?: String;
  type?: String;
  version?: String;
  canBeRemoved?: Boolean;
  dependentServices?: ServiceUpdateManyInput;
}

export interface TenantUpdateDataInput {
  name?: String;
  description?: String;
  users?: UserUpdateManyInput;
}

export interface ServiceUpdateManyInput {
  create?: ServiceCreateInput[] | ServiceCreateInput;
  update?:
    | ServiceUpdateWithWhereUniqueNestedInput[]
    | ServiceUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ServiceUpsertWithWhereUniqueNestedInput[]
    | ServiceUpsertWithWhereUniqueNestedInput;
  delete?: ServiceWhereUniqueInput[] | ServiceWhereUniqueInput;
  connect?: ServiceWhereUniqueInput[] | ServiceWhereUniqueInput;
  disconnect?: ServiceWhereUniqueInput[] | ServiceWhereUniqueInput;
  deleteMany?: ServiceScalarWhereInput[] | ServiceScalarWhereInput;
  updateMany?:
    | ServiceUpdateManyWithWhereNestedInput[]
    | ServiceUpdateManyWithWhereNestedInput;
}

export type TenantWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ServiceUpdateWithWhereUniqueNestedInput {
  where: ServiceWhereUniqueInput;
  data: ServiceUpdateDataInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  tenantRoles_every?: TenantRoleWhereInput;
  tenantRoles_some?: TenantRoleWhereInput;
  tenantRoles_none?: TenantRoleWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface ServiceUpdateDataInput {
  name?: String;
  code?: String;
  description?: String;
  status?: String;
  type?: String;
  version?: String;
  canBeRemoved?: Boolean;
  dependentServices?: ServiceUpdateManyInput;
  environments?: EnvironmentUpdateManyWithoutServiceInput;
}

export interface TenantWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  users_every?: UserWhereInput;
  users_some?: UserWhereInput;
  users_none?: UserWhereInput;
  AND?: TenantWhereInput[] | TenantWhereInput;
  OR?: TenantWhereInput[] | TenantWhereInput;
  NOT?: TenantWhereInput[] | TenantWhereInput;
}

export interface EnvironmentUpdateManyWithoutServiceInput {
  create?:
    | EnvironmentCreateWithoutServiceInput[]
    | EnvironmentCreateWithoutServiceInput;
  delete?: EnvironmentWhereUniqueInput[] | EnvironmentWhereUniqueInput;
  connect?: EnvironmentWhereUniqueInput[] | EnvironmentWhereUniqueInput;
  disconnect?: EnvironmentWhereUniqueInput[] | EnvironmentWhereUniqueInput;
  update?:
    | EnvironmentUpdateWithWhereUniqueWithoutServiceInput[]
    | EnvironmentUpdateWithWhereUniqueWithoutServiceInput;
  upsert?:
    | EnvironmentUpsertWithWhereUniqueWithoutServiceInput[]
    | EnvironmentUpsertWithWhereUniqueWithoutServiceInput;
  deleteMany?: EnvironmentScalarWhereInput[] | EnvironmentScalarWhereInput;
  updateMany?:
    | EnvironmentUpdateManyWithWhereNestedInput[]
    | EnvironmentUpdateManyWithWhereNestedInput;
}

export interface TenantRoleUpdateWithWhereUniqueWithoutUserInput {
  where: TenantRoleWhereUniqueInput;
  data: TenantRoleUpdateWithoutUserDataInput;
}

export interface EnvironmentUpdateWithWhereUniqueWithoutServiceInput {
  where: EnvironmentWhereUniqueInput;
  data: EnvironmentUpdateWithoutServiceDataInput;
}

export interface UserUpdateDataInput {
  name?: String;
  email?: String;
  password?: String;
  tenantRoles?: TenantRoleUpdateManyWithoutUserInput;
}

export interface EnvironmentCreateInput {
  name: String;
  code: String;
  description?: String;
  region?: String;
  classification: String;
  service: ServiceCreateOneWithoutEnvironmentsInput;
  tenants?: EnvironmentTenantCreateManyWithoutEnvironmentInput;
  components?: ComponentInstanceCreateManyWithoutEnvironmentInput;
}

export interface UserUpdateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  update?:
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput;
  upsert?:
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface EnvironmentTenantUpdateManyWithoutEnvironmentInput {
  create?:
    | EnvironmentTenantCreateWithoutEnvironmentInput[]
    | EnvironmentTenantCreateWithoutEnvironmentInput;
  delete?:
    | EnvironmentTenantWhereUniqueInput[]
    | EnvironmentTenantWhereUniqueInput;
  connect?:
    | EnvironmentTenantWhereUniqueInput[]
    | EnvironmentTenantWhereUniqueInput;
  disconnect?:
    | EnvironmentTenantWhereUniqueInput[]
    | EnvironmentTenantWhereUniqueInput;
  update?:
    | EnvironmentTenantUpdateWithWhereUniqueWithoutEnvironmentInput[]
    | EnvironmentTenantUpdateWithWhereUniqueWithoutEnvironmentInput;
  upsert?:
    | EnvironmentTenantUpsertWithWhereUniqueWithoutEnvironmentInput[]
    | EnvironmentTenantUpsertWithWhereUniqueWithoutEnvironmentInput;
  deleteMany?:
    | EnvironmentTenantScalarWhereInput[]
    | EnvironmentTenantScalarWhereInput;
  updateMany?:
    | EnvironmentTenantUpdateManyWithWhereNestedInput[]
    | EnvironmentTenantUpdateManyWithWhereNestedInput;
}

export interface TenantCreateOneInput {
  create?: TenantCreateInput;
  connect?: TenantWhereUniqueInput;
}

export interface EnvironmentTenantUpdateWithWhereUniqueWithoutEnvironmentInput {
  where: EnvironmentTenantWhereUniqueInput;
  data: EnvironmentTenantUpdateWithoutEnvironmentDataInput;
}

export type TenantAttributeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  parameter?: String;
}>;

export interface EnvironmentTenantUpdateWithoutEnvironmentDataInput {
  name?: String;
  code?: String;
  class?: String;
  primaryContactEmail?: String;
  tenantCreationDate?: DateTimeInput;
  customer?: CustomerUpdateOneRequiredWithoutTenantsInput;
  attributes?: TenantAttributeUpdateManyWithoutTenantInput;
}

export interface UserCreateInput {
  name: String;
  email: String;
  password: String;
  tenantRoles?: TenantRoleCreateManyWithoutUserInput;
}

export interface CustomerUpdateOneRequiredWithoutTenantsInput {
  create?: CustomerCreateWithoutTenantsInput;
  update?: CustomerUpdateWithoutTenantsDataInput;
  upsert?: CustomerUpsertWithoutTenantsInput;
  connect?: CustomerWhereUniqueInput;
}

export type TenantRoleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CustomerUpdateWithoutTenantsDataInput {
  name?: String;
  code?: String;
  status?: String;
  contacts?: CustomerContactUpdateManyWithoutCustomerInput;
}

export interface ServiceUpdateManyMutationInput {
  name?: String;
  code?: String;
  description?: String;
  status?: String;
  type?: String;
  version?: String;
  canBeRemoved?: Boolean;
}

export interface CustomerContactUpdateManyWithoutCustomerInput {
  create?:
    | CustomerContactCreateWithoutCustomerInput[]
    | CustomerContactCreateWithoutCustomerInput;
  delete?: CustomerContactWhereUniqueInput[] | CustomerContactWhereUniqueInput;
  connect?: CustomerContactWhereUniqueInput[] | CustomerContactWhereUniqueInput;
  disconnect?:
    | CustomerContactWhereUniqueInput[]
    | CustomerContactWhereUniqueInput;
  update?:
    | CustomerContactUpdateWithWhereUniqueWithoutCustomerInput[]
    | CustomerContactUpdateWithWhereUniqueWithoutCustomerInput;
  upsert?:
    | CustomerContactUpsertWithWhereUniqueWithoutCustomerInput[]
    | CustomerContactUpsertWithWhereUniqueWithoutCustomerInput;
  deleteMany?:
    | CustomerContactScalarWhereInput[]
    | CustomerContactScalarWhereInput;
  updateMany?:
    | CustomerContactUpdateManyWithWhereNestedInput[]
    | CustomerContactUpdateManyWithWhereNestedInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface CustomerContactUpdateWithWhereUniqueWithoutCustomerInput {
  where: CustomerContactWhereUniqueInput;
  data: CustomerContactUpdateWithoutCustomerDataInput;
}

export interface EnvironmentTenantUpdateInput {
  name?: String;
  code?: String;
  class?: String;
  primaryContactEmail?: String;
  tenantCreationDate?: DateTimeInput;
  customer?: CustomerUpdateOneRequiredWithoutTenantsInput;
  environment?: EnvironmentUpdateOneRequiredWithoutTenantsInput;
  attributes?: TenantAttributeUpdateManyWithoutTenantInput;
}

export interface CustomerContactUpdateWithoutCustomerDataInput {
  name?: String;
  email?: String;
  phone?: String;
  sms?: String;
}

export interface ArchitectureTypeCreateOneInput {
  create?: ArchitectureTypeCreateInput;
  connect?: ArchitectureTypeWhereUniqueInput;
}

export type ArchitectureTierWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface ComponentTemplateCreateManyInput {
  create?: ComponentTemplateCreateInput[] | ComponentTemplateCreateInput;
  connect?:
    | ComponentTemplateWhereUniqueInput[]
    | ComponentTemplateWhereUniqueInput;
}

export interface CustomerContactScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  sms?: String;
  sms_not?: String;
  sms_in?: String[] | String;
  sms_not_in?: String[] | String;
  sms_lt?: String;
  sms_lte?: String;
  sms_gt?: String;
  sms_gte?: String;
  sms_contains?: String;
  sms_not_contains?: String;
  sms_starts_with?: String;
  sms_not_starts_with?: String;
  sms_ends_with?: String;
  sms_not_ends_with?: String;
  AND?: CustomerContactScalarWhereInput[] | CustomerContactScalarWhereInput;
  OR?: CustomerContactScalarWhereInput[] | CustomerContactScalarWhereInput;
  NOT?: CustomerContactScalarWhereInput[] | CustomerContactScalarWhereInput;
}

export interface ArchitectureTierCreateOneInput {
  create?: ArchitectureTierCreateInput;
  connect?: ArchitectureTierWhereUniqueInput;
}

export interface CustomerContactUpdateManyWithWhereNestedInput {
  where: CustomerContactScalarWhereInput;
  data: CustomerContactUpdateManyDataInput;
}

export interface ArchitectureDefinitionUpdateInput {
  name?: String;
  code?: String;
  description?: String;
  type?: ArchitectureTypeUpdateOneRequiredInput;
  components?: ComponentTemplateUpdateManyInput;
}

export interface CustomerContactUpdateManyDataInput {
  name?: String;
  email?: String;
  phone?: String;
  sms?: String;
}

export interface ArchitectureTypeUpdateDataInput {
  name?: String;
}

export interface CustomerUpsertWithoutTenantsInput {
  update: CustomerUpdateWithoutTenantsDataInput;
  create: CustomerCreateWithoutTenantsInput;
}

export interface ComponentTemplateUpdateManyInput {
  create?: ComponentTemplateCreateInput[] | ComponentTemplateCreateInput;
  update?:
    | ComponentTemplateUpdateWithWhereUniqueNestedInput[]
    | ComponentTemplateUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ComponentTemplateUpsertWithWhereUniqueNestedInput[]
    | ComponentTemplateUpsertWithWhereUniqueNestedInput;
  delete?:
    | ComponentTemplateWhereUniqueInput[]
    | ComponentTemplateWhereUniqueInput;
  connect?:
    | ComponentTemplateWhereUniqueInput[]
    | ComponentTemplateWhereUniqueInput;
  disconnect?:
    | ComponentTemplateWhereUniqueInput[]
    | ComponentTemplateWhereUniqueInput;
  deleteMany?:
    | ComponentTemplateScalarWhereInput[]
    | ComponentTemplateScalarWhereInput;
  updateMany?:
    | ComponentTemplateUpdateManyWithWhereNestedInput[]
    | ComponentTemplateUpdateManyWithWhereNestedInput;
}

export interface TenantAttributeUpdateManyWithoutTenantInput {
  create?:
    | TenantAttributeCreateWithoutTenantInput[]
    | TenantAttributeCreateWithoutTenantInput;
  delete?: TenantAttributeWhereUniqueInput[] | TenantAttributeWhereUniqueInput;
  connect?: TenantAttributeWhereUniqueInput[] | TenantAttributeWhereUniqueInput;
  disconnect?:
    | TenantAttributeWhereUniqueInput[]
    | TenantAttributeWhereUniqueInput;
  update?:
    | TenantAttributeUpdateWithWhereUniqueWithoutTenantInput[]
    | TenantAttributeUpdateWithWhereUniqueWithoutTenantInput;
  upsert?:
    | TenantAttributeUpsertWithWhereUniqueWithoutTenantInput[]
    | TenantAttributeUpsertWithWhereUniqueWithoutTenantInput;
  deleteMany?:
    | TenantAttributeScalarWhereInput[]
    | TenantAttributeScalarWhereInput;
  updateMany?:
    | TenantAttributeUpdateManyWithWhereNestedInput[]
    | TenantAttributeUpdateManyWithWhereNestedInput;
}

export interface ComponentTemplateUpdateDataInput {
  name?: String;
  code?: String;
  tier?: ArchitectureTierUpdateOneRequiredInput;
}

export interface TenantAttributeUpdateWithWhereUniqueWithoutTenantInput {
  where: TenantAttributeWhereUniqueInput;
  data: TenantAttributeUpdateWithoutTenantDataInput;
}

export interface ArchitectureTierUpdateDataInput {
  name?: String;
  priority?: Int;
}

export interface TenantAttributeUpdateWithoutTenantDataInput {
  parameter?: String;
  value?: String;
}

export interface ComponentTemplateUpsertWithWhereUniqueNestedInput {
  where: ComponentTemplateWhereUniqueInput;
  update: ComponentTemplateUpdateDataInput;
  create: ComponentTemplateCreateInput;
}

export interface TenantAttributeUpsertWithWhereUniqueWithoutTenantInput {
  where: TenantAttributeWhereUniqueInput;
  update: TenantAttributeUpdateWithoutTenantDataInput;
  create: TenantAttributeCreateWithoutTenantInput;
}

export interface ComponentTemplateUpdateManyWithWhereNestedInput {
  where: ComponentTemplateScalarWhereInput;
  data: ComponentTemplateUpdateManyDataInput;
}

export interface TenantAttributeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  parameter?: String;
  parameter_not?: String;
  parameter_in?: String[] | String;
  parameter_not_in?: String[] | String;
  parameter_lt?: String;
  parameter_lte?: String;
  parameter_gt?: String;
  parameter_gte?: String;
  parameter_contains?: String;
  parameter_not_contains?: String;
  parameter_starts_with?: String;
  parameter_not_starts_with?: String;
  parameter_ends_with?: String;
  parameter_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?: TenantAttributeScalarWhereInput[] | TenantAttributeScalarWhereInput;
  OR?: TenantAttributeScalarWhereInput[] | TenantAttributeScalarWhereInput;
  NOT?: TenantAttributeScalarWhereInput[] | TenantAttributeScalarWhereInput;
}

export interface ArchitectureDefinitionUpdateManyMutationInput {
  name?: String;
  code?: String;
  description?: String;
}

export interface TenantAttributeUpdateManyWithWhereNestedInput {
  where: TenantAttributeScalarWhereInput;
  data: TenantAttributeUpdateManyDataInput;
}

export interface EnvironmentUpdateInput {
  name?: String;
  code?: String;
  description?: String;
  region?: String;
  classification?: String;
  service?: ServiceUpdateOneRequiredWithoutEnvironmentsInput;
  tenants?: EnvironmentTenantUpdateManyWithoutEnvironmentInput;
  components?: ComponentInstanceUpdateManyWithoutEnvironmentInput;
}

export interface TenantAttributeUpdateManyDataInput {
  parameter?: String;
  value?: String;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface EnvironmentTenantUpsertWithWhereUniqueWithoutEnvironmentInput {
  where: EnvironmentTenantWhereUniqueInput;
  update: EnvironmentTenantUpdateWithoutEnvironmentDataInput;
  create: EnvironmentTenantCreateWithoutEnvironmentInput;
}

export type ArchitectureTypeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface EnvironmentTenantScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  class?: String;
  class_not?: String;
  class_in?: String[] | String;
  class_not_in?: String[] | String;
  class_lt?: String;
  class_lte?: String;
  class_gt?: String;
  class_gte?: String;
  class_contains?: String;
  class_not_contains?: String;
  class_starts_with?: String;
  class_not_starts_with?: String;
  class_ends_with?: String;
  class_not_ends_with?: String;
  primaryContactEmail?: String;
  primaryContactEmail_not?: String;
  primaryContactEmail_in?: String[] | String;
  primaryContactEmail_not_in?: String[] | String;
  primaryContactEmail_lt?: String;
  primaryContactEmail_lte?: String;
  primaryContactEmail_gt?: String;
  primaryContactEmail_gte?: String;
  primaryContactEmail_contains?: String;
  primaryContactEmail_not_contains?: String;
  primaryContactEmail_starts_with?: String;
  primaryContactEmail_not_starts_with?: String;
  primaryContactEmail_ends_with?: String;
  primaryContactEmail_not_ends_with?: String;
  tenantCreationDate?: DateTimeInput;
  tenantCreationDate_not?: DateTimeInput;
  tenantCreationDate_in?: DateTimeInput[] | DateTimeInput;
  tenantCreationDate_not_in?: DateTimeInput[] | DateTimeInput;
  tenantCreationDate_lt?: DateTimeInput;
  tenantCreationDate_lte?: DateTimeInput;
  tenantCreationDate_gt?: DateTimeInput;
  tenantCreationDate_gte?: DateTimeInput;
  AND?: EnvironmentTenantScalarWhereInput[] | EnvironmentTenantScalarWhereInput;
  OR?: EnvironmentTenantScalarWhereInput[] | EnvironmentTenantScalarWhereInput;
  NOT?: EnvironmentTenantScalarWhereInput[] | EnvironmentTenantScalarWhereInput;
}

export interface CustomerContactSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CustomerContactWhereInput;
  AND?:
    | CustomerContactSubscriptionWhereInput[]
    | CustomerContactSubscriptionWhereInput;
  OR?:
    | CustomerContactSubscriptionWhereInput[]
    | CustomerContactSubscriptionWhereInput;
  NOT?:
    | CustomerContactSubscriptionWhereInput[]
    | CustomerContactSubscriptionWhereInput;
}

export interface EnvironmentTenantUpdateManyWithWhereNestedInput {
  where: EnvironmentTenantScalarWhereInput;
  data: EnvironmentTenantUpdateManyDataInput;
}

export interface ComponentInstanceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ComponentInstanceWhereInput;
  AND?:
    | ComponentInstanceSubscriptionWhereInput[]
    | ComponentInstanceSubscriptionWhereInput;
  OR?:
    | ComponentInstanceSubscriptionWhereInput[]
    | ComponentInstanceSubscriptionWhereInput;
  NOT?:
    | ComponentInstanceSubscriptionWhereInput[]
    | ComponentInstanceSubscriptionWhereInput;
}

export interface EnvironmentTenantUpdateManyDataInput {
  name?: String;
  code?: String;
  class?: String;
  primaryContactEmail?: String;
  tenantCreationDate?: DateTimeInput;
}

export interface EnvironmentTenantWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  class?: String;
  class_not?: String;
  class_in?: String[] | String;
  class_not_in?: String[] | String;
  class_lt?: String;
  class_lte?: String;
  class_gt?: String;
  class_gte?: String;
  class_contains?: String;
  class_not_contains?: String;
  class_starts_with?: String;
  class_not_starts_with?: String;
  class_ends_with?: String;
  class_not_ends_with?: String;
  primaryContactEmail?: String;
  primaryContactEmail_not?: String;
  primaryContactEmail_in?: String[] | String;
  primaryContactEmail_not_in?: String[] | String;
  primaryContactEmail_lt?: String;
  primaryContactEmail_lte?: String;
  primaryContactEmail_gt?: String;
  primaryContactEmail_gte?: String;
  primaryContactEmail_contains?: String;
  primaryContactEmail_not_contains?: String;
  primaryContactEmail_starts_with?: String;
  primaryContactEmail_not_starts_with?: String;
  primaryContactEmail_ends_with?: String;
  primaryContactEmail_not_ends_with?: String;
  tenantCreationDate?: DateTimeInput;
  tenantCreationDate_not?: DateTimeInput;
  tenantCreationDate_in?: DateTimeInput[] | DateTimeInput;
  tenantCreationDate_not_in?: DateTimeInput[] | DateTimeInput;
  tenantCreationDate_lt?: DateTimeInput;
  tenantCreationDate_lte?: DateTimeInput;
  tenantCreationDate_gt?: DateTimeInput;
  tenantCreationDate_gte?: DateTimeInput;
  customer?: CustomerWhereInput;
  environment?: EnvironmentWhereInput;
  attributes_every?: TenantAttributeWhereInput;
  attributes_some?: TenantAttributeWhereInput;
  attributes_none?: TenantAttributeWhereInput;
  AND?: EnvironmentTenantWhereInput[] | EnvironmentTenantWhereInput;
  OR?: EnvironmentTenantWhereInput[] | EnvironmentTenantWhereInput;
  NOT?: EnvironmentTenantWhereInput[] | EnvironmentTenantWhereInput;
}

export interface ComponentInstanceUpdateManyWithoutEnvironmentInput {
  create?:
    | ComponentInstanceCreateWithoutEnvironmentInput[]
    | ComponentInstanceCreateWithoutEnvironmentInput;
  delete?:
    | ComponentInstanceWhereUniqueInput[]
    | ComponentInstanceWhereUniqueInput;
  connect?:
    | ComponentInstanceWhereUniqueInput[]
    | ComponentInstanceWhereUniqueInput;
  disconnect?:
    | ComponentInstanceWhereUniqueInput[]
    | ComponentInstanceWhereUniqueInput;
  update?:
    | ComponentInstanceUpdateWithWhereUniqueWithoutEnvironmentInput[]
    | ComponentInstanceUpdateWithWhereUniqueWithoutEnvironmentInput;
  upsert?:
    | ComponentInstanceUpsertWithWhereUniqueWithoutEnvironmentInput[]
    | ComponentInstanceUpsertWithWhereUniqueWithoutEnvironmentInput;
  deleteMany?:
    | ComponentInstanceScalarWhereInput[]
    | ComponentInstanceScalarWhereInput;
  updateMany?:
    | ComponentInstanceUpdateManyWithWhereNestedInput[]
    | ComponentInstanceUpdateManyWithWhereNestedInput;
}

export interface ComponentInstanceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  environment?: EnvironmentWhereInput;
  component?: ComponentTemplateWhereInput;
  attributes_every?: ComponentAttributeWhereInput;
  attributes_some?: ComponentAttributeWhereInput;
  attributes_none?: ComponentAttributeWhereInput;
  AND?: ComponentInstanceWhereInput[] | ComponentInstanceWhereInput;
  OR?: ComponentInstanceWhereInput[] | ComponentInstanceWhereInput;
  NOT?: ComponentInstanceWhereInput[] | ComponentInstanceWhereInput;
}

export interface ComponentInstanceUpdateWithWhereUniqueWithoutEnvironmentInput {
  where: ComponentInstanceWhereUniqueInput;
  data: ComponentInstanceUpdateWithoutEnvironmentDataInput;
}

export interface ArchitectureTypeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: ArchitectureTypeWhereInput[] | ArchitectureTypeWhereInput;
  OR?: ArchitectureTypeWhereInput[] | ArchitectureTypeWhereInput;
  NOT?: ArchitectureTypeWhereInput[] | ArchitectureTypeWhereInput;
}

export interface ComponentInstanceUpdateWithoutEnvironmentDataInput {
  name?: String;
  component?: ComponentTemplateUpdateOneRequiredInput;
  attributes?: ComponentAttributeUpdateManyWithoutComponentInput;
}

export interface UserUpdateInput {
  name?: String;
  email?: String;
  password?: String;
  tenantRoles?: TenantRoleUpdateManyWithoutUserInput;
}

export interface ComponentTemplateUpdateOneRequiredInput {
  create?: ComponentTemplateCreateInput;
  update?: ComponentTemplateUpdateDataInput;
  upsert?: ComponentTemplateUpsertNestedInput;
  connect?: ComponentTemplateWhereUniqueInput;
}

export interface UserUpdateOneRequiredWithoutTenantRolesInput {
  create?: UserCreateWithoutTenantRolesInput;
  update?: UserUpdateWithoutTenantRolesDataInput;
  upsert?: UserUpsertWithoutTenantRolesInput;
  connect?: UserWhereUniqueInput;
}

export interface ComponentTemplateUpsertNestedInput {
  update: ComponentTemplateUpdateDataInput;
  create: ComponentTemplateCreateInput;
}

export type ComponentInstanceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface ComponentAttributeUpdateManyWithoutComponentInput {
  create?:
    | ComponentAttributeCreateWithoutComponentInput[]
    | ComponentAttributeCreateWithoutComponentInput;
  delete?:
    | ComponentAttributeWhereUniqueInput[]
    | ComponentAttributeWhereUniqueInput;
  connect?:
    | ComponentAttributeWhereUniqueInput[]
    | ComponentAttributeWhereUniqueInput;
  disconnect?:
    | ComponentAttributeWhereUniqueInput[]
    | ComponentAttributeWhereUniqueInput;
  update?:
    | ComponentAttributeUpdateWithWhereUniqueWithoutComponentInput[]
    | ComponentAttributeUpdateWithWhereUniqueWithoutComponentInput;
  upsert?:
    | ComponentAttributeUpsertWithWhereUniqueWithoutComponentInput[]
    | ComponentAttributeUpsertWithWhereUniqueWithoutComponentInput;
  deleteMany?:
    | ComponentAttributeScalarWhereInput[]
    | ComponentAttributeScalarWhereInput;
  updateMany?:
    | ComponentAttributeUpdateManyWithWhereNestedInput[]
    | ComponentAttributeUpdateManyWithWhereNestedInput;
}

export type ComponentTemplateWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  code?: String;
}>;

export interface ComponentAttributeUpdateWithWhereUniqueWithoutComponentInput {
  where: ComponentAttributeWhereUniqueInput;
  data: ComponentAttributeUpdateWithoutComponentDataInput;
}

export type CustomerWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  code?: String;
}>;

export interface ComponentAttributeUpdateWithoutComponentDataInput {
  parameter?: String;
  value?: String;
}

export interface TenantAttributeCreateInput {
  parameter: String;
  value: String;
  tenant: EnvironmentTenantCreateOneWithoutAttributesInput;
}

export interface ComponentAttributeUpsertWithWhereUniqueWithoutComponentInput {
  where: ComponentAttributeWhereUniqueInput;
  update: ComponentAttributeUpdateWithoutComponentDataInput;
  create: ComponentAttributeCreateWithoutComponentInput;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface ComponentAttributeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  parameter?: String;
  parameter_not?: String;
  parameter_in?: String[] | String;
  parameter_not_in?: String[] | String;
  parameter_lt?: String;
  parameter_lte?: String;
  parameter_gt?: String;
  parameter_gte?: String;
  parameter_contains?: String;
  parameter_not_contains?: String;
  parameter_starts_with?: String;
  parameter_not_starts_with?: String;
  parameter_ends_with?: String;
  parameter_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?:
    | ComponentAttributeScalarWhereInput[]
    | ComponentAttributeScalarWhereInput;
  OR?:
    | ComponentAttributeScalarWhereInput[]
    | ComponentAttributeScalarWhereInput;
  NOT?:
    | ComponentAttributeScalarWhereInput[]
    | ComponentAttributeScalarWhereInput;
}

export interface TenantRoleUpdateManyDataInput {
  role?: Role;
}

export interface ComponentAttributeUpdateManyWithWhereNestedInput {
  where: ComponentAttributeScalarWhereInput;
  data: ComponentAttributeUpdateManyDataInput;
}

export interface TenantRoleUpsertWithWhereUniqueWithoutUserInput {
  where: TenantRoleWhereUniqueInput;
  update: TenantRoleUpdateWithoutUserDataInput;
  create: TenantRoleCreateWithoutUserInput;
}

export interface ComponentAttributeUpdateManyDataInput {
  parameter?: String;
  value?: String;
}

export interface TenantUpdateOneRequiredInput {
  create?: TenantCreateInput;
  update?: TenantUpdateDataInput;
  upsert?: TenantUpsertNestedInput;
  connect?: TenantWhereUniqueInput;
}

export interface ComponentInstanceUpsertWithWhereUniqueWithoutEnvironmentInput {
  where: ComponentInstanceWhereUniqueInput;
  update: ComponentInstanceUpdateWithoutEnvironmentDataInput;
  create: ComponentInstanceCreateWithoutEnvironmentInput;
}

export interface TenantRoleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  tenant?: TenantWhereInput;
  role?: Role;
  role_not?: Role;
  role_in?: Role[] | Role;
  role_not_in?: Role[] | Role;
  AND?: TenantRoleWhereInput[] | TenantRoleWhereInput;
  OR?: TenantRoleWhereInput[] | TenantRoleWhereInput;
  NOT?: TenantRoleWhereInput[] | TenantRoleWhereInput;
}

export interface ComponentInstanceScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: ComponentInstanceScalarWhereInput[] | ComponentInstanceScalarWhereInput;
  OR?: ComponentInstanceScalarWhereInput[] | ComponentInstanceScalarWhereInput;
  NOT?: ComponentInstanceScalarWhereInput[] | ComponentInstanceScalarWhereInput;
}

export interface TenantRoleUpdateManyWithoutUserInput {
  create?:
    | TenantRoleCreateWithoutUserInput[]
    | TenantRoleCreateWithoutUserInput;
  delete?: TenantRoleWhereUniqueInput[] | TenantRoleWhereUniqueInput;
  connect?: TenantRoleWhereUniqueInput[] | TenantRoleWhereUniqueInput;
  disconnect?: TenantRoleWhereUniqueInput[] | TenantRoleWhereUniqueInput;
  update?:
    | TenantRoleUpdateWithWhereUniqueWithoutUserInput[]
    | TenantRoleUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | TenantRoleUpsertWithWhereUniqueWithoutUserInput[]
    | TenantRoleUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: TenantRoleScalarWhereInput[] | TenantRoleScalarWhereInput;
  updateMany?:
    | TenantRoleUpdateManyWithWhereNestedInput[]
    | TenantRoleUpdateManyWithWhereNestedInput;
}

export interface ComponentInstanceUpdateManyWithWhereNestedInput {
  where: ComponentInstanceScalarWhereInput;
  data: ComponentInstanceUpdateManyDataInput;
}

export interface TenantUpdateInput {
  name?: String;
  description?: String;
  users?: UserUpdateManyInput;
}

export interface ComponentInstanceUpdateManyDataInput {
  name?: String;
}

export interface TenantRoleCreateManyWithoutUserInput {
  create?:
    | TenantRoleCreateWithoutUserInput[]
    | TenantRoleCreateWithoutUserInput;
  connect?: TenantRoleWhereUniqueInput[] | TenantRoleWhereUniqueInput;
}

export interface EnvironmentUpsertWithWhereUniqueWithoutServiceInput {
  where: EnvironmentWhereUniqueInput;
  update: EnvironmentUpdateWithoutServiceDataInput;
  create: EnvironmentCreateWithoutServiceInput;
}

export interface TenantCreateInput {
  name: String;
  description?: String;
  users?: UserCreateManyInput;
}

export interface EnvironmentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  region?: String;
  region_not?: String;
  region_in?: String[] | String;
  region_not_in?: String[] | String;
  region_lt?: String;
  region_lte?: String;
  region_gt?: String;
  region_gte?: String;
  region_contains?: String;
  region_not_contains?: String;
  region_starts_with?: String;
  region_not_starts_with?: String;
  region_ends_with?: String;
  region_not_ends_with?: String;
  classification?: String;
  classification_not?: String;
  classification_in?: String[] | String;
  classification_not_in?: String[] | String;
  classification_lt?: String;
  classification_lte?: String;
  classification_gt?: String;
  classification_gte?: String;
  classification_contains?: String;
  classification_not_contains?: String;
  classification_starts_with?: String;
  classification_not_starts_with?: String;
  classification_ends_with?: String;
  classification_not_ends_with?: String;
  AND?: EnvironmentScalarWhereInput[] | EnvironmentScalarWhereInput;
  OR?: EnvironmentScalarWhereInput[] | EnvironmentScalarWhereInput;
  NOT?: EnvironmentScalarWhereInput[] | EnvironmentScalarWhereInput;
}

export interface EnvironmentTenantUpdateManyMutationInput {
  name?: String;
  code?: String;
  class?: String;
  primaryContactEmail?: String;
  tenantCreationDate?: DateTimeInput;
}

export interface EnvironmentUpdateManyWithWhereNestedInput {
  where: EnvironmentScalarWhereInput;
  data: EnvironmentUpdateManyDataInput;
}

export interface ArchitectureDefinitionCreateInput {
  name: String;
  code: String;
  description?: String;
  type: ArchitectureTypeCreateOneInput;
  components?: ComponentTemplateCreateManyInput;
}

export interface EnvironmentUpdateManyDataInput {
  name?: String;
  code?: String;
  description?: String;
  region?: String;
  classification?: String;
}

export interface ComponentTemplateCreateInput {
  name: String;
  code: String;
  tier: ArchitectureTierCreateOneInput;
}

export interface ServiceUpsertWithWhereUniqueNestedInput {
  where: ServiceWhereUniqueInput;
  update: ServiceUpdateDataInput;
  create: ServiceCreateInput;
}

export interface ArchitectureTypeUpdateOneRequiredInput {
  create?: ArchitectureTypeCreateInput;
  update?: ArchitectureTypeUpdateDataInput;
  upsert?: ArchitectureTypeUpsertNestedInput;
  connect?: ArchitectureTypeWhereUniqueInput;
}

export interface ServiceScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  status?: String;
  status_not?: String;
  status_in?: String[] | String;
  status_not_in?: String[] | String;
  status_lt?: String;
  status_lte?: String;
  status_gt?: String;
  status_gte?: String;
  status_contains?: String;
  status_not_contains?: String;
  status_starts_with?: String;
  status_not_starts_with?: String;
  status_ends_with?: String;
  status_not_ends_with?: String;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  version?: String;
  version_not?: String;
  version_in?: String[] | String;
  version_not_in?: String[] | String;
  version_lt?: String;
  version_lte?: String;
  version_gt?: String;
  version_gte?: String;
  version_contains?: String;
  version_not_contains?: String;
  version_starts_with?: String;
  version_not_starts_with?: String;
  version_ends_with?: String;
  version_not_ends_with?: String;
  canBeRemoved?: Boolean;
  canBeRemoved_not?: Boolean;
  AND?: ServiceScalarWhereInput[] | ServiceScalarWhereInput;
  OR?: ServiceScalarWhereInput[] | ServiceScalarWhereInput;
  NOT?: ServiceScalarWhereInput[] | ServiceScalarWhereInput;
}

export interface ComponentTemplateUpdateWithWhereUniqueNestedInput {
  where: ComponentTemplateWhereUniqueInput;
  data: ComponentTemplateUpdateDataInput;
}

export interface ServiceUpdateManyWithWhereNestedInput {
  where: ServiceScalarWhereInput;
  data: ServiceUpdateManyDataInput;
}

export interface ArchitectureTierUpsertNestedInput {
  update: ArchitectureTierUpdateDataInput;
  create: ArchitectureTierCreateInput;
}

export interface ServiceUpdateManyDataInput {
  name?: String;
  code?: String;
  description?: String;
  status?: String;
  type?: String;
  version?: String;
  canBeRemoved?: Boolean;
}

export interface ComponentTemplateUpdateManyDataInput {
  name?: String;
  code?: String;
}

export interface ServiceUpsertWithoutEnvironmentsInput {
  update: ServiceUpdateWithoutEnvironmentsDataInput;
  create: ServiceCreateWithoutEnvironmentsInput;
}

export interface ArchitectureTierUpdateInput {
  name?: String;
  priority?: Int;
}

export interface EnvironmentUpsertWithoutComponentsInput {
  update: EnvironmentUpdateWithoutComponentsDataInput;
  create: EnvironmentCreateWithoutComponentsInput;
}

export interface EnvironmentTenantSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EnvironmentTenantWhereInput;
  AND?:
    | EnvironmentTenantSubscriptionWhereInput[]
    | EnvironmentTenantSubscriptionWhereInput;
  OR?:
    | EnvironmentTenantSubscriptionWhereInput[]
    | EnvironmentTenantSubscriptionWhereInput;
  NOT?:
    | EnvironmentTenantSubscriptionWhereInput[]
    | EnvironmentTenantSubscriptionWhereInput;
}

export interface ComponentInstanceUpsertWithoutAttributesInput {
  update: ComponentInstanceUpdateWithoutAttributesDataInput;
  create: ComponentInstanceCreateWithoutAttributesInput;
}

export interface ServiceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  status?: String;
  status_not?: String;
  status_in?: String[] | String;
  status_not_in?: String[] | String;
  status_lt?: String;
  status_lte?: String;
  status_gt?: String;
  status_gte?: String;
  status_contains?: String;
  status_not_contains?: String;
  status_starts_with?: String;
  status_not_starts_with?: String;
  status_ends_with?: String;
  status_not_ends_with?: String;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  version?: String;
  version_not?: String;
  version_in?: String[] | String;
  version_not_in?: String[] | String;
  version_lt?: String;
  version_lte?: String;
  version_gt?: String;
  version_gte?: String;
  version_contains?: String;
  version_not_contains?: String;
  version_starts_with?: String;
  version_not_starts_with?: String;
  version_ends_with?: String;
  version_not_ends_with?: String;
  canBeRemoved?: Boolean;
  canBeRemoved_not?: Boolean;
  dependentServices_every?: ServiceWhereInput;
  dependentServices_some?: ServiceWhereInput;
  dependentServices_none?: ServiceWhereInput;
  environments_every?: EnvironmentWhereInput;
  environments_some?: EnvironmentWhereInput;
  environments_none?: EnvironmentWhereInput;
  AND?: ServiceWhereInput[] | ServiceWhereInput;
  OR?: ServiceWhereInput[] | ServiceWhereInput;
  NOT?: ServiceWhereInput[] | ServiceWhereInput;
}

export interface ComponentAttributeUpdateManyMutationInput {
  parameter?: String;
  value?: String;
}

export interface ArchitectureTypeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ArchitectureTypeWhereInput;
  AND?:
    | ArchitectureTypeSubscriptionWhereInput[]
    | ArchitectureTypeSubscriptionWhereInput;
  OR?:
    | ArchitectureTypeSubscriptionWhereInput[]
    | ArchitectureTypeSubscriptionWhereInput;
  NOT?:
    | ArchitectureTypeSubscriptionWhereInput[]
    | ArchitectureTypeSubscriptionWhereInput;
}

export interface ComponentInstanceCreateInput {
  name: String;
  environment: EnvironmentCreateOneWithoutComponentsInput;
  component: ComponentTemplateCreateOneInput;
  attributes?: ComponentAttributeCreateManyWithoutComponentInput;
}

export interface UserUpsertWithoutTenantRolesInput {
  update: UserUpdateWithoutTenantRolesDataInput;
  create: UserCreateWithoutTenantRolesInput;
}

export interface ComponentInstanceUpdateInput {
  name?: String;
  environment?: EnvironmentUpdateOneRequiredWithoutComponentsInput;
  component?: ComponentTemplateUpdateOneRequiredInput;
  attributes?: ComponentAttributeUpdateManyWithoutComponentInput;
}

export interface TenantAttributeUpdateManyMutationInput {
  parameter?: String;
  value?: String;
}

export interface ComponentInstanceUpdateManyMutationInput {
  name?: String;
}

export interface EnvironmentTenantCreateWithoutAttributesInput {
  name: String;
  code: String;
  class?: String;
  primaryContactEmail?: String;
  tenantCreationDate?: DateTimeInput;
  customer: CustomerCreateOneWithoutTenantsInput;
  environment: EnvironmentCreateOneWithoutTenantsInput;
}

export interface ComponentTemplateUpdateInput {
  name?: String;
  code?: String;
  tier?: ArchitectureTierUpdateOneRequiredInput;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface ComponentTemplateUpdateManyMutationInput {
  name?: String;
  code?: String;
}

export interface TenantUpsertNestedInput {
  update: TenantUpdateDataInput;
  create: TenantCreateInput;
}

export interface CustomerCreateInput {
  name: String;
  code: String;
  status?: String;
  contacts?: CustomerContactCreateManyWithoutCustomerInput;
  tenants?: EnvironmentTenantCreateManyWithoutCustomerInput;
}

export interface ComponentTemplateWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  tier?: ArchitectureTierWhereInput;
  AND?: ComponentTemplateWhereInput[] | ComponentTemplateWhereInput;
  OR?: ComponentTemplateWhereInput[] | ComponentTemplateWhereInput;
  NOT?: ComponentTemplateWhereInput[] | ComponentTemplateWhereInput;
}

export interface EnvironmentTenantCreateManyWithoutCustomerInput {
  create?:
    | EnvironmentTenantCreateWithoutCustomerInput[]
    | EnvironmentTenantCreateWithoutCustomerInput;
  connect?:
    | EnvironmentTenantWhereUniqueInput[]
    | EnvironmentTenantWhereUniqueInput;
}

export interface TenantRoleCreateWithoutUserInput {
  tenant: TenantCreateOneInput;
  role: Role;
}

export interface EnvironmentTenantCreateWithoutCustomerInput {
  name: String;
  code: String;
  class?: String;
  primaryContactEmail?: String;
  tenantCreationDate?: DateTimeInput;
  environment: EnvironmentCreateOneWithoutTenantsInput;
  attributes?: TenantAttributeCreateManyWithoutTenantInput;
}

export interface ServiceUpdateInput {
  name?: String;
  code?: String;
  description?: String;
  status?: String;
  type?: String;
  version?: String;
  canBeRemoved?: Boolean;
  dependentServices?: ServiceUpdateManyInput;
  environments?: EnvironmentUpdateManyWithoutServiceInput;
}

export interface EnvironmentCreateOneWithoutTenantsInput {
  create?: EnvironmentCreateWithoutTenantsInput;
  connect?: EnvironmentWhereUniqueInput;
}

export interface ArchitectureTypeCreateInput {
  name: String;
}

export interface EnvironmentCreateWithoutTenantsInput {
  name: String;
  code: String;
  description?: String;
  region?: String;
  classification: String;
  service: ServiceCreateOneWithoutEnvironmentsInput;
  components?: ComponentInstanceCreateManyWithoutEnvironmentInput;
}

export interface ArchitectureTypeUpsertNestedInput {
  update: ArchitectureTypeUpdateDataInput;
  create: ArchitectureTypeCreateInput;
}

export interface CustomerUpdateInput {
  name?: String;
  code?: String;
  status?: String;
  contacts?: CustomerContactUpdateManyWithoutCustomerInput;
  tenants?: EnvironmentTenantUpdateManyWithoutCustomerInput;
}

export interface ComponentTemplateScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  AND?: ComponentTemplateScalarWhereInput[] | ComponentTemplateScalarWhereInput;
  OR?: ComponentTemplateScalarWhereInput[] | ComponentTemplateScalarWhereInput;
  NOT?: ComponentTemplateScalarWhereInput[] | ComponentTemplateScalarWhereInput;
}

export interface EnvironmentTenantUpdateManyWithoutCustomerInput {
  create?:
    | EnvironmentTenantCreateWithoutCustomerInput[]
    | EnvironmentTenantCreateWithoutCustomerInput;
  delete?:
    | EnvironmentTenantWhereUniqueInput[]
    | EnvironmentTenantWhereUniqueInput;
  connect?:
    | EnvironmentTenantWhereUniqueInput[]
    | EnvironmentTenantWhereUniqueInput;
  disconnect?:
    | EnvironmentTenantWhereUniqueInput[]
    | EnvironmentTenantWhereUniqueInput;
  update?:
    | EnvironmentTenantUpdateWithWhereUniqueWithoutCustomerInput[]
    | EnvironmentTenantUpdateWithWhereUniqueWithoutCustomerInput;
  upsert?:
    | EnvironmentTenantUpsertWithWhereUniqueWithoutCustomerInput[]
    | EnvironmentTenantUpsertWithWhereUniqueWithoutCustomerInput;
  deleteMany?:
    | EnvironmentTenantScalarWhereInput[]
    | EnvironmentTenantScalarWhereInput;
  updateMany?:
    | EnvironmentTenantUpdateManyWithWhereNestedInput[]
    | EnvironmentTenantUpdateManyWithWhereNestedInput;
}

export interface TenantAttributeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TenantAttributeWhereInput;
  AND?:
    | TenantAttributeSubscriptionWhereInput[]
    | TenantAttributeSubscriptionWhereInput;
  OR?:
    | TenantAttributeSubscriptionWhereInput[]
    | TenantAttributeSubscriptionWhereInput;
  NOT?:
    | TenantAttributeSubscriptionWhereInput[]
    | TenantAttributeSubscriptionWhereInput;
}

export interface EnvironmentTenantUpdateWithWhereUniqueWithoutCustomerInput {
  where: EnvironmentTenantWhereUniqueInput;
  data: EnvironmentTenantUpdateWithoutCustomerDataInput;
}

export interface CustomerContactWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  sms?: String;
  sms_not?: String;
  sms_in?: String[] | String;
  sms_not_in?: String[] | String;
  sms_lt?: String;
  sms_lte?: String;
  sms_gt?: String;
  sms_gte?: String;
  sms_contains?: String;
  sms_not_contains?: String;
  sms_starts_with?: String;
  sms_not_starts_with?: String;
  sms_ends_with?: String;
  sms_not_ends_with?: String;
  customer?: CustomerWhereInput;
  AND?: CustomerContactWhereInput[] | CustomerContactWhereInput;
  OR?: CustomerContactWhereInput[] | CustomerContactWhereInput;
  NOT?: CustomerContactWhereInput[] | CustomerContactWhereInput;
}

export interface EnvironmentTenantUpdateWithoutCustomerDataInput {
  name?: String;
  code?: String;
  class?: String;
  primaryContactEmail?: String;
  tenantCreationDate?: DateTimeInput;
  environment?: EnvironmentUpdateOneRequiredWithoutTenantsInput;
  attributes?: TenantAttributeUpdateManyWithoutTenantInput;
}

export interface UserCreateWithoutTenantRolesInput {
  name: String;
  email: String;
  password: String;
}

export interface EnvironmentUpdateOneRequiredWithoutTenantsInput {
  create?: EnvironmentCreateWithoutTenantsInput;
  update?: EnvironmentUpdateWithoutTenantsDataInput;
  upsert?: EnvironmentUpsertWithoutTenantsInput;
  connect?: EnvironmentWhereUniqueInput;
}

export interface TenantUpdateManyMutationInput {
  name?: String;
  description?: String;
}

export interface EnvironmentUpdateWithoutTenantsDataInput {
  name?: String;
  code?: String;
  description?: String;
  region?: String;
  classification?: String;
  service?: ServiceUpdateOneRequiredWithoutEnvironmentsInput;
  components?: ComponentInstanceUpdateManyWithoutEnvironmentInput;
}

export interface TenantRoleUpdateWithoutUserDataInput {
  tenant?: TenantUpdateOneRequiredInput;
  role?: Role;
}

export interface EnvironmentUpsertWithoutTenantsInput {
  update: EnvironmentUpdateWithoutTenantsDataInput;
  create: EnvironmentCreateWithoutTenantsInput;
}

export interface UserCreateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface EnvironmentTenantUpsertWithWhereUniqueWithoutCustomerInput {
  where: EnvironmentTenantWhereUniqueInput;
  update: EnvironmentTenantUpdateWithoutCustomerDataInput;
  create: EnvironmentTenantCreateWithoutCustomerInput;
}

export interface ArchitectureTierCreateInput {
  name: String;
  priority: Int;
}

export interface CustomerUpdateManyMutationInput {
  name?: String;
  code?: String;
  status?: String;
}

export interface EnvironmentUpdateManyMutationInput {
  name?: String;
  code?: String;
  description?: String;
  region?: String;
  classification?: String;
}

export interface CustomerContactCreateInput {
  name: String;
  email: String;
  phone?: String;
  sms?: String;
  customer: CustomerCreateOneWithoutContactsInput;
}

export interface UserUpdateManyMutationInput {
  name?: String;
  email?: String;
  password?: String;
}

export interface CustomerCreateOneWithoutContactsInput {
  create?: CustomerCreateWithoutContactsInput;
  connect?: CustomerWhereUniqueInput;
}

export interface TenantRoleUpdateManyWithWhereNestedInput {
  where: TenantRoleScalarWhereInput;
  data: TenantRoleUpdateManyDataInput;
}

export interface CustomerCreateWithoutContactsInput {
  name: String;
  code: String;
  status?: String;
  tenants?: EnvironmentTenantCreateManyWithoutCustomerInput;
}

export interface EnvironmentTenantCreateInput {
  name: String;
  code: String;
  class?: String;
  primaryContactEmail?: String;
  tenantCreationDate?: DateTimeInput;
  customer: CustomerCreateOneWithoutTenantsInput;
  environment: EnvironmentCreateOneWithoutTenantsInput;
  attributes?: TenantAttributeCreateManyWithoutTenantInput;
}

export interface CustomerUpsertWithoutContactsInput {
  update: CustomerUpdateWithoutContactsDataInput;
  create: CustomerCreateWithoutContactsInput;
}

export interface CustomerUpdateWithoutContactsDataInput {
  name?: String;
  code?: String;
  status?: String;
  tenants?: EnvironmentTenantUpdateManyWithoutCustomerInput;
}

export interface CustomerUpdateOneRequiredWithoutContactsInput {
  create?: CustomerCreateWithoutContactsInput;
  update?: CustomerUpdateWithoutContactsDataInput;
  upsert?: CustomerUpsertWithoutContactsInput;
  connect?: CustomerWhereUniqueInput;
}

export interface CustomerContactUpdateInput {
  name?: String;
  email?: String;
  phone?: String;
  sms?: String;
  customer?: CustomerUpdateOneRequiredWithoutContactsInput;
}

export interface ArchitectureTierUpdateOneRequiredInput {
  create?: ArchitectureTierCreateInput;
  update?: ArchitectureTierUpdateDataInput;
  upsert?: ArchitectureTierUpsertNestedInput;
  connect?: ArchitectureTierWhereUniqueInput;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface EnvironmentTenantUpdateOneRequiredWithoutAttributesInput {
  create?: EnvironmentTenantCreateWithoutAttributesInput;
  update?: EnvironmentTenantUpdateWithoutAttributesDataInput;
  upsert?: EnvironmentTenantUpsertWithoutAttributesInput;
  connect?: EnvironmentTenantWhereUniqueInput;
}

export interface CustomerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CustomerWhereInput;
  AND?: CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput;
  OR?: CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput;
  NOT?: CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface ArchitectureTier {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  priority: Int;
}

export interface ArchitectureTierPromise
  extends Promise<ArchitectureTier>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  priority: () => Promise<Int>;
}

export interface ArchitectureTierSubscription
  extends Promise<AsyncIterator<ArchitectureTier>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  priority: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateArchitectureDefinition {
  count: Int;
}

export interface AggregateArchitectureDefinitionPromise
  extends Promise<AggregateArchitectureDefinition>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateArchitectureDefinitionSubscription
  extends Promise<AsyncIterator<AggregateArchitectureDefinition>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomerContact {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  email: String;
  phone?: String;
  sms?: String;
}

export interface CustomerContactPromise
  extends Promise<CustomerContact>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  sms: () => Promise<String>;
  customer: <T = CustomerPromise>() => T;
}

export interface CustomerContactSubscription
  extends Promise<AsyncIterator<CustomerContact>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  sms: () => Promise<AsyncIterator<String>>;
  customer: <T = CustomerSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface Customer {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  code: String;
  status?: String;
}

export interface CustomerPromise extends Promise<Customer>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  status: () => Promise<String>;
  contacts: <T = FragmentableArray<CustomerContact>>(
    args?: {
      where?: CustomerContactWhereInput;
      orderBy?: CustomerContactOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tenants: <T = FragmentableArray<EnvironmentTenant>>(
    args?: {
      where?: EnvironmentTenantWhereInput;
      orderBy?: EnvironmentTenantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CustomerSubscription
  extends Promise<AsyncIterator<Customer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
  contacts: <T = Promise<AsyncIterator<CustomerContactSubscription>>>(
    args?: {
      where?: CustomerContactWhereInput;
      orderBy?: CustomerContactOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tenants: <T = Promise<AsyncIterator<EnvironmentTenantSubscription>>>(
    args?: {
      where?: EnvironmentTenantWhereInput;
      orderBy?: EnvironmentTenantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EnvironmentTenant {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  code: String;
  class?: String;
  primaryContactEmail?: String;
  tenantCreationDate?: DateTimeOutput;
}

export interface EnvironmentTenantPromise
  extends Promise<EnvironmentTenant>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  class: () => Promise<String>;
  primaryContactEmail: () => Promise<String>;
  tenantCreationDate: () => Promise<DateTimeOutput>;
  customer: <T = CustomerPromise>() => T;
  environment: <T = EnvironmentPromise>() => T;
  attributes: <T = FragmentableArray<TenantAttribute>>(
    args?: {
      where?: TenantAttributeWhereInput;
      orderBy?: TenantAttributeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface EnvironmentTenantSubscription
  extends Promise<AsyncIterator<EnvironmentTenant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  class: () => Promise<AsyncIterator<String>>;
  primaryContactEmail: () => Promise<AsyncIterator<String>>;
  tenantCreationDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  customer: <T = CustomerSubscription>() => T;
  environment: <T = EnvironmentSubscription>() => T;
  attributes: <T = Promise<AsyncIterator<TenantAttributeSubscription>>>(
    args?: {
      where?: TenantAttributeWhereInput;
      orderBy?: TenantAttributeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateTenantRole {
  count: Int;
}

export interface AggregateTenantRolePromise
  extends Promise<AggregateTenantRole>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTenantRoleSubscription
  extends Promise<AsyncIterator<AggregateTenantRole>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface ArchitectureTierConnection {
  pageInfo: PageInfo;
  edges: ArchitectureTierEdge[];
}

export interface ArchitectureTierConnectionPromise
  extends Promise<ArchitectureTierConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ArchitectureTierEdge>>() => T;
  aggregate: <T = AggregateArchitectureTierPromise>() => T;
}

export interface ArchitectureTierConnectionSubscription
  extends Promise<AsyncIterator<ArchitectureTierConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ArchitectureTierEdgeSubscription>>>() => T;
  aggregate: <T = AggregateArchitectureTierSubscription>() => T;
}

export interface TenantRoleEdge {
  node: TenantRole;
  cursor: String;
}

export interface TenantRoleEdgePromise
  extends Promise<TenantRoleEdge>,
    Fragmentable {
  node: <T = TenantRolePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TenantRoleEdgeSubscription
  extends Promise<AsyncIterator<TenantRoleEdge>>,
    Fragmentable {
  node: <T = TenantRoleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TenantRoleConnection {
  pageInfo: PageInfo;
  edges: TenantRoleEdge[];
}

export interface TenantRoleConnectionPromise
  extends Promise<TenantRoleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TenantRoleEdge>>() => T;
  aggregate: <T = AggregateTenantRolePromise>() => T;
}

export interface TenantRoleConnectionSubscription
  extends Promise<AsyncIterator<TenantRoleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TenantRoleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTenantRoleSubscription>() => T;
}

export interface AggregateTenantAttribute {
  count: Int;
}

export interface AggregateTenantAttributePromise
  extends Promise<AggregateTenantAttribute>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTenantAttributeSubscription
  extends Promise<AsyncIterator<AggregateTenantAttribute>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TenantAttributeConnection {
  pageInfo: PageInfo;
  edges: TenantAttributeEdge[];
}

export interface TenantAttributeConnectionPromise
  extends Promise<TenantAttributeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TenantAttributeEdge>>() => T;
  aggregate: <T = AggregateTenantAttributePromise>() => T;
}

export interface TenantAttributeConnectionSubscription
  extends Promise<AsyncIterator<TenantAttributeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TenantAttributeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTenantAttributeSubscription>() => T;
}

export interface ArchitectureDefinitionSubscriptionPayload {
  mutation: MutationType;
  node: ArchitectureDefinition;
  updatedFields: String[];
  previousValues: ArchitectureDefinitionPreviousValues;
}

export interface ArchitectureDefinitionSubscriptionPayloadPromise
  extends Promise<ArchitectureDefinitionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ArchitectureDefinitionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ArchitectureDefinitionPreviousValuesPromise>() => T;
}

export interface ArchitectureDefinitionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ArchitectureDefinitionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ArchitectureDefinitionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ArchitectureDefinitionPreviousValuesSubscription>() => T;
}

export interface TenantEdge {
  node: Tenant;
  cursor: String;
}

export interface TenantEdgePromise extends Promise<TenantEdge>, Fragmentable {
  node: <T = TenantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TenantEdgeSubscription
  extends Promise<AsyncIterator<TenantEdge>>,
    Fragmentable {
  node: <T = TenantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ArchitectureDefinitionPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  code: String;
  description?: String;
}

export interface ArchitectureDefinitionPreviousValuesPromise
  extends Promise<ArchitectureDefinitionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  description: () => Promise<String>;
}

export interface ArchitectureDefinitionPreviousValuesSubscription
  extends Promise<AsyncIterator<ArchitectureDefinitionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface ArchitectureDefinition {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  code: String;
  description?: String;
}

export interface ArchitectureDefinitionPromise
  extends Promise<ArchitectureDefinition>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  description: () => Promise<String>;
  type: <T = ArchitectureTypePromise>() => T;
  components: <T = FragmentableArray<ComponentTemplate>>(
    args?: {
      where?: ComponentTemplateWhereInput;
      orderBy?: ComponentTemplateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ArchitectureDefinitionSubscription
  extends Promise<AsyncIterator<ArchitectureDefinition>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  type: <T = ArchitectureTypeSubscription>() => T;
  components: <T = Promise<AsyncIterator<ComponentTemplateSubscription>>>(
    args?: {
      where?: ComponentTemplateWhereInput;
      orderBy?: ComponentTemplateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ArchitectureDefinitionConnection {
  pageInfo: PageInfo;
  edges: ArchitectureDefinitionEdge[];
}

export interface ArchitectureDefinitionConnectionPromise
  extends Promise<ArchitectureDefinitionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ArchitectureDefinitionEdge>>() => T;
  aggregate: <T = AggregateArchitectureDefinitionPromise>() => T;
}

export interface ArchitectureDefinitionConnectionSubscription
  extends Promise<AsyncIterator<ArchitectureDefinitionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ArchitectureDefinitionEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateArchitectureDefinitionSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface ArchitectureTierSubscriptionPayload {
  mutation: MutationType;
  node: ArchitectureTier;
  updatedFields: String[];
  previousValues: ArchitectureTierPreviousValues;
}

export interface ArchitectureTierSubscriptionPayloadPromise
  extends Promise<ArchitectureTierSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ArchitectureTierPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ArchitectureTierPreviousValuesPromise>() => T;
}

export interface ArchitectureTierSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ArchitectureTierSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ArchitectureTierSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ArchitectureTierPreviousValuesSubscription>() => T;
}

export interface ArchitectureType {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface ArchitectureTypePromise
  extends Promise<ArchitectureType>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface ArchitectureTypeSubscription
  extends Promise<AsyncIterator<ArchitectureType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ArchitectureTierPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  priority: Int;
}

export interface ArchitectureTierPreviousValuesPromise
  extends Promise<ArchitectureTierPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  priority: () => Promise<Int>;
}

export interface ArchitectureTierPreviousValuesSubscription
  extends Promise<AsyncIterator<ArchitectureTierPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  priority: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateService {
  count: Int;
}

export interface AggregateServicePromise
  extends Promise<AggregateService>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateServiceSubscription
  extends Promise<AsyncIterator<AggregateService>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ServiceConnection {
  pageInfo: PageInfo;
  edges: ServiceEdge[];
}

export interface ServiceConnectionPromise
  extends Promise<ServiceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ServiceEdge>>() => T;
  aggregate: <T = AggregateServicePromise>() => T;
}

export interface ServiceConnectionSubscription
  extends Promise<AsyncIterator<ServiceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ServiceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateServiceSubscription>() => T;
}

export interface ArchitectureTypeSubscriptionPayload {
  mutation: MutationType;
  node: ArchitectureType;
  updatedFields: String[];
  previousValues: ArchitectureTypePreviousValues;
}

export interface ArchitectureTypeSubscriptionPayloadPromise
  extends Promise<ArchitectureTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ArchitectureTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ArchitectureTypePreviousValuesPromise>() => T;
}

export interface ArchitectureTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ArchitectureTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ArchitectureTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ArchitectureTypePreviousValuesSubscription>() => T;
}

export interface EnvironmentTenantEdge {
  node: EnvironmentTenant;
  cursor: String;
}

export interface EnvironmentTenantEdgePromise
  extends Promise<EnvironmentTenantEdge>,
    Fragmentable {
  node: <T = EnvironmentTenantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EnvironmentTenantEdgeSubscription
  extends Promise<AsyncIterator<EnvironmentTenantEdge>>,
    Fragmentable {
  node: <T = EnvironmentTenantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ArchitectureTypePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface ArchitectureTypePreviousValuesPromise
  extends Promise<ArchitectureTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface ArchitectureTypePreviousValuesSubscription
  extends Promise<AsyncIterator<ArchitectureTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEnvironment {
  count: Int;
}

export interface AggregateEnvironmentPromise
  extends Promise<AggregateEnvironment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEnvironmentSubscription
  extends Promise<AsyncIterator<AggregateEnvironment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Service {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  code: String;
  description?: String;
  status: String;
  type: String;
  version?: String;
  canBeRemoved: Boolean;
}

export interface ServicePromise extends Promise<Service>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  description: () => Promise<String>;
  status: () => Promise<String>;
  type: () => Promise<String>;
  version: () => Promise<String>;
  canBeRemoved: () => Promise<Boolean>;
  dependentServices: <T = FragmentableArray<Service>>(
    args?: {
      where?: ServiceWhereInput;
      orderBy?: ServiceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  environments: <T = FragmentableArray<Environment>>(
    args?: {
      where?: EnvironmentWhereInput;
      orderBy?: EnvironmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ServiceSubscription
  extends Promise<AsyncIterator<Service>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  version: () => Promise<AsyncIterator<String>>;
  canBeRemoved: () => Promise<AsyncIterator<Boolean>>;
  dependentServices: <T = Promise<AsyncIterator<ServiceSubscription>>>(
    args?: {
      where?: ServiceWhereInput;
      orderBy?: ServiceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  environments: <T = Promise<AsyncIterator<EnvironmentSubscription>>>(
    args?: {
      where?: EnvironmentWhereInput;
      orderBy?: EnvironmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface EnvironmentConnection {
  pageInfo: PageInfo;
  edges: EnvironmentEdge[];
}

export interface EnvironmentConnectionPromise
  extends Promise<EnvironmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EnvironmentEdge>>() => T;
  aggregate: <T = AggregateEnvironmentPromise>() => T;
}

export interface EnvironmentConnectionSubscription
  extends Promise<AsyncIterator<EnvironmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EnvironmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEnvironmentSubscription>() => T;
}

export interface ComponentAttributeSubscriptionPayload {
  mutation: MutationType;
  node: ComponentAttribute;
  updatedFields: String[];
  previousValues: ComponentAttributePreviousValues;
}

export interface ComponentAttributeSubscriptionPayloadPromise
  extends Promise<ComponentAttributeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ComponentAttributePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ComponentAttributePreviousValuesPromise>() => T;
}

export interface ComponentAttributeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ComponentAttributeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ComponentAttributeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ComponentAttributePreviousValuesSubscription>() => T;
}

export interface CustomerContactEdge {
  node: CustomerContact;
  cursor: String;
}

export interface CustomerContactEdgePromise
  extends Promise<CustomerContactEdge>,
    Fragmentable {
  node: <T = CustomerContactPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerContactEdgeSubscription
  extends Promise<AsyncIterator<CustomerContactEdge>>,
    Fragmentable {
  node: <T = CustomerContactSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ComponentAttributePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  parameter: String;
  value: String;
}

export interface ComponentAttributePreviousValuesPromise
  extends Promise<ComponentAttributePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  parameter: () => Promise<String>;
  value: () => Promise<String>;
}

export interface ComponentAttributePreviousValuesSubscription
  extends Promise<AsyncIterator<ComponentAttributePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  parameter: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCustomer {
  count: Int;
}

export interface AggregateCustomerPromise
  extends Promise<AggregateCustomer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerSubscription
  extends Promise<AsyncIterator<AggregateCustomer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Environment {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  code: String;
  description?: String;
  region?: String;
  classification: String;
}

export interface EnvironmentPromise extends Promise<Environment>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  description: () => Promise<String>;
  region: () => Promise<String>;
  classification: () => Promise<String>;
  service: <T = ServicePromise>() => T;
  tenants: <T = FragmentableArray<EnvironmentTenant>>(
    args?: {
      where?: EnvironmentTenantWhereInput;
      orderBy?: EnvironmentTenantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  components: <T = FragmentableArray<ComponentInstance>>(
    args?: {
      where?: ComponentInstanceWhereInput;
      orderBy?: ComponentInstanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface EnvironmentSubscription
  extends Promise<AsyncIterator<Environment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  region: () => Promise<AsyncIterator<String>>;
  classification: () => Promise<AsyncIterator<String>>;
  service: <T = ServiceSubscription>() => T;
  tenants: <T = Promise<AsyncIterator<EnvironmentTenantSubscription>>>(
    args?: {
      where?: EnvironmentTenantWhereInput;
      orderBy?: EnvironmentTenantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  components: <T = Promise<AsyncIterator<ComponentInstanceSubscription>>>(
    args?: {
      where?: ComponentInstanceWhereInput;
      orderBy?: ComponentInstanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CustomerConnection {
  pageInfo: PageInfo;
  edges: CustomerEdge[];
}

export interface CustomerConnectionPromise
  extends Promise<CustomerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerEdge>>() => T;
  aggregate: <T = AggregateCustomerPromise>() => T;
}

export interface CustomerConnectionSubscription
  extends Promise<AsyncIterator<CustomerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerSubscription>() => T;
}

export interface ComponentInstanceSubscriptionPayload {
  mutation: MutationType;
  node: ComponentInstance;
  updatedFields: String[];
  previousValues: ComponentInstancePreviousValues;
}

export interface ComponentInstanceSubscriptionPayloadPromise
  extends Promise<ComponentInstanceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ComponentInstancePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ComponentInstancePreviousValuesPromise>() => T;
}

export interface ComponentInstanceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ComponentInstanceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ComponentInstanceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ComponentInstancePreviousValuesSubscription>() => T;
}

export interface ComponentTemplateEdge {
  node: ComponentTemplate;
  cursor: String;
}

export interface ComponentTemplateEdgePromise
  extends Promise<ComponentTemplateEdge>,
    Fragmentable {
  node: <T = ComponentTemplatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ComponentTemplateEdgeSubscription
  extends Promise<AsyncIterator<ComponentTemplateEdge>>,
    Fragmentable {
  node: <T = ComponentTemplateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ComponentInstancePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface ComponentInstancePreviousValuesPromise
  extends Promise<ComponentInstancePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface ComponentInstancePreviousValuesSubscription
  extends Promise<AsyncIterator<ComponentInstancePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateComponentInstance {
  count: Int;
}

export interface AggregateComponentInstancePromise
  extends Promise<AggregateComponentInstance>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateComponentInstanceSubscription
  extends Promise<AsyncIterator<AggregateComponentInstance>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ComponentInstance {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface ComponentInstancePromise
  extends Promise<ComponentInstance>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  environment: <T = EnvironmentPromise>() => T;
  component: <T = ComponentTemplatePromise>() => T;
  attributes: <T = FragmentableArray<ComponentAttribute>>(
    args?: {
      where?: ComponentAttributeWhereInput;
      orderBy?: ComponentAttributeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ComponentInstanceSubscription
  extends Promise<AsyncIterator<ComponentInstance>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  environment: <T = EnvironmentSubscription>() => T;
  component: <T = ComponentTemplateSubscription>() => T;
  attributes: <T = Promise<AsyncIterator<ComponentAttributeSubscription>>>(
    args?: {
      where?: ComponentAttributeWhereInput;
      orderBy?: ComponentAttributeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ComponentInstanceConnection {
  pageInfo: PageInfo;
  edges: ComponentInstanceEdge[];
}

export interface ComponentInstanceConnectionPromise
  extends Promise<ComponentInstanceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ComponentInstanceEdge>>() => T;
  aggregate: <T = AggregateComponentInstancePromise>() => T;
}

export interface ComponentInstanceConnectionSubscription
  extends Promise<AsyncIterator<ComponentInstanceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ComponentInstanceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateComponentInstanceSubscription>() => T;
}

export interface ComponentTemplateSubscriptionPayload {
  mutation: MutationType;
  node: ComponentTemplate;
  updatedFields: String[];
  previousValues: ComponentTemplatePreviousValues;
}

export interface ComponentTemplateSubscriptionPayloadPromise
  extends Promise<ComponentTemplateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ComponentTemplatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ComponentTemplatePreviousValuesPromise>() => T;
}

export interface ComponentTemplateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ComponentTemplateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ComponentTemplateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ComponentTemplatePreviousValuesSubscription>() => T;
}

export interface ComponentAttributeEdge {
  node: ComponentAttribute;
  cursor: String;
}

export interface ComponentAttributeEdgePromise
  extends Promise<ComponentAttributeEdge>,
    Fragmentable {
  node: <T = ComponentAttributePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ComponentAttributeEdgeSubscription
  extends Promise<AsyncIterator<ComponentAttributeEdge>>,
    Fragmentable {
  node: <T = ComponentAttributeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ComponentTemplatePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  code: String;
}

export interface ComponentTemplatePreviousValuesPromise
  extends Promise<ComponentTemplatePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  code: () => Promise<String>;
}

export interface ComponentTemplatePreviousValuesSubscription
  extends Promise<AsyncIterator<ComponentTemplatePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
}

export interface ArchitectureDefinitionEdge {
  node: ArchitectureDefinition;
  cursor: String;
}

export interface ArchitectureDefinitionEdgePromise
  extends Promise<ArchitectureDefinitionEdge>,
    Fragmentable {
  node: <T = ArchitectureDefinitionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ArchitectureDefinitionEdgeSubscription
  extends Promise<AsyncIterator<ArchitectureDefinitionEdge>>,
    Fragmentable {
  node: <T = ArchitectureDefinitionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ComponentAttribute {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  parameter: String;
  value: String;
}

export interface ComponentAttributePromise
  extends Promise<ComponentAttribute>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  parameter: () => Promise<String>;
  value: () => Promise<String>;
  component: <T = ComponentInstancePromise>() => T;
}

export interface ComponentAttributeSubscription
  extends Promise<AsyncIterator<ComponentAttribute>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  parameter: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
  component: <T = ComponentInstanceSubscription>() => T;
}

export interface TenantAttribute {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  parameter: String;
  value: String;
}

export interface TenantAttributePromise
  extends Promise<TenantAttribute>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  parameter: () => Promise<String>;
  value: () => Promise<String>;
  tenant: <T = EnvironmentTenantPromise>() => T;
}

export interface TenantAttributeSubscription
  extends Promise<AsyncIterator<TenantAttribute>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  parameter: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
  tenant: <T = EnvironmentTenantSubscription>() => T;
}

export interface CustomerSubscriptionPayload {
  mutation: MutationType;
  node: Customer;
  updatedFields: String[];
  previousValues: CustomerPreviousValues;
}

export interface CustomerSubscriptionPayloadPromise
  extends Promise<CustomerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerPreviousValuesPromise>() => T;
}

export interface CustomerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerPreviousValuesSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomerPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  code: String;
  status?: String;
}

export interface CustomerPreviousValuesPromise
  extends Promise<CustomerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  status: () => Promise<String>;
}

export interface CustomerPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTenant {
  count: Int;
}

export interface AggregateTenantPromise
  extends Promise<AggregateTenant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTenantSubscription
  extends Promise<AsyncIterator<AggregateTenant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateArchitectureType {
  count: Int;
}

export interface AggregateArchitectureTypePromise
  extends Promise<AggregateArchitectureType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateArchitectureTypeSubscription
  extends Promise<AsyncIterator<AggregateArchitectureType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TenantRole {
  id: ID_Output;
  role: Role;
}

export interface TenantRolePromise extends Promise<TenantRole>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  tenant: <T = TenantPromise>() => T;
  role: () => Promise<Role>;
}

export interface TenantRoleSubscription
  extends Promise<AsyncIterator<TenantRole>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  tenant: <T = TenantSubscription>() => T;
  role: () => Promise<AsyncIterator<Role>>;
}

export interface CustomerContactSubscriptionPayload {
  mutation: MutationType;
  node: CustomerContact;
  updatedFields: String[];
  previousValues: CustomerContactPreviousValues;
}

export interface CustomerContactSubscriptionPayloadPromise
  extends Promise<CustomerContactSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerContactPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerContactPreviousValuesPromise>() => T;
}

export interface CustomerContactSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerContactSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerContactSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerContactPreviousValuesSubscription>() => T;
}

export interface Tenant {
  id: ID_Output;
  name: String;
  description?: String;
}

export interface TenantPromise extends Promise<Tenant>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  users: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface TenantSubscription
  extends Promise<AsyncIterator<Tenant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CustomerContactPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  email: String;
  phone?: String;
  sms?: String;
}

export interface CustomerContactPreviousValuesPromise
  extends Promise<CustomerContactPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  sms: () => Promise<String>;
}

export interface CustomerContactPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerContactPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  sms: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEnvironmentTenant {
  count: Int;
}

export interface AggregateEnvironmentTenantPromise
  extends Promise<AggregateEnvironmentTenant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEnvironmentTenantSubscription
  extends Promise<AsyncIterator<AggregateEnvironmentTenant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ArchitectureTypeEdge {
  node: ArchitectureType;
  cursor: String;
}

export interface ArchitectureTypeEdgePromise
  extends Promise<ArchitectureTypeEdge>,
    Fragmentable {
  node: <T = ArchitectureTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ArchitectureTypeEdgeSubscription
  extends Promise<AsyncIterator<ArchitectureTypeEdge>>,
    Fragmentable {
  node: <T = ArchitectureTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EnvironmentEdge {
  node: Environment;
  cursor: String;
}

export interface EnvironmentEdgePromise
  extends Promise<EnvironmentEdge>,
    Fragmentable {
  node: <T = EnvironmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EnvironmentEdgeSubscription
  extends Promise<AsyncIterator<EnvironmentEdge>>,
    Fragmentable {
  node: <T = EnvironmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EnvironmentSubscriptionPayload {
  mutation: MutationType;
  node: Environment;
  updatedFields: String[];
  previousValues: EnvironmentPreviousValues;
}

export interface EnvironmentSubscriptionPayloadPromise
  extends Promise<EnvironmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EnvironmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EnvironmentPreviousValuesPromise>() => T;
}

export interface EnvironmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EnvironmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EnvironmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EnvironmentPreviousValuesSubscription>() => T;
}

export interface CustomerContactConnection {
  pageInfo: PageInfo;
  edges: CustomerContactEdge[];
}

export interface CustomerContactConnectionPromise
  extends Promise<CustomerContactConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerContactEdge>>() => T;
  aggregate: <T = AggregateCustomerContactPromise>() => T;
}

export interface CustomerContactConnectionSubscription
  extends Promise<AsyncIterator<CustomerContactConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerContactEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerContactSubscription>() => T;
}

export interface EnvironmentPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  code: String;
  description?: String;
  region?: String;
  classification: String;
}

export interface EnvironmentPreviousValuesPromise
  extends Promise<EnvironmentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  description: () => Promise<String>;
  region: () => Promise<String>;
  classification: () => Promise<String>;
}

export interface EnvironmentPreviousValuesSubscription
  extends Promise<AsyncIterator<EnvironmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  region: () => Promise<AsyncIterator<String>>;
  classification: () => Promise<AsyncIterator<String>>;
}

export interface AggregateComponentTemplate {
  count: Int;
}

export interface AggregateComponentTemplatePromise
  extends Promise<AggregateComponentTemplate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateComponentTemplateSubscription
  extends Promise<AsyncIterator<AggregateComponentTemplate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ArchitectureTypeConnection {
  pageInfo: PageInfo;
  edges: ArchitectureTypeEdge[];
}

export interface ArchitectureTypeConnectionPromise
  extends Promise<ArchitectureTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ArchitectureTypeEdge>>() => T;
  aggregate: <T = AggregateArchitectureTypePromise>() => T;
}

export interface ArchitectureTypeConnectionSubscription
  extends Promise<AsyncIterator<ArchitectureTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ArchitectureTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateArchitectureTypeSubscription>() => T;
}

export interface ComponentInstanceEdge {
  node: ComponentInstance;
  cursor: String;
}

export interface ComponentInstanceEdgePromise
  extends Promise<ComponentInstanceEdge>,
    Fragmentable {
  node: <T = ComponentInstancePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ComponentInstanceEdgeSubscription
  extends Promise<AsyncIterator<ComponentInstanceEdge>>,
    Fragmentable {
  node: <T = ComponentInstanceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EnvironmentTenantSubscriptionPayload {
  mutation: MutationType;
  node: EnvironmentTenant;
  updatedFields: String[];
  previousValues: EnvironmentTenantPreviousValues;
}

export interface EnvironmentTenantSubscriptionPayloadPromise
  extends Promise<EnvironmentTenantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EnvironmentTenantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EnvironmentTenantPreviousValuesPromise>() => T;
}

export interface EnvironmentTenantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EnvironmentTenantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EnvironmentTenantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EnvironmentTenantPreviousValuesSubscription>() => T;
}

export interface ComponentAttributeConnection {
  pageInfo: PageInfo;
  edges: ComponentAttributeEdge[];
}

export interface ComponentAttributeConnectionPromise
  extends Promise<ComponentAttributeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ComponentAttributeEdge>>() => T;
  aggregate: <T = AggregateComponentAttributePromise>() => T;
}

export interface ComponentAttributeConnectionSubscription
  extends Promise<AsyncIterator<ComponentAttributeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ComponentAttributeEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateComponentAttributeSubscription>() => T;
}

export interface EnvironmentTenantPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  code: String;
  class?: String;
  primaryContactEmail?: String;
  tenantCreationDate?: DateTimeOutput;
}

export interface EnvironmentTenantPreviousValuesPromise
  extends Promise<EnvironmentTenantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  class: () => Promise<String>;
  primaryContactEmail: () => Promise<String>;
  tenantCreationDate: () => Promise<DateTimeOutput>;
}

export interface EnvironmentTenantPreviousValuesSubscription
  extends Promise<AsyncIterator<EnvironmentTenantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  class: () => Promise<AsyncIterator<String>>;
  primaryContactEmail: () => Promise<AsyncIterator<String>>;
  tenantCreationDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TenantRolePreviousValues {
  id: ID_Output;
  role: Role;
}

export interface TenantRolePreviousValuesPromise
  extends Promise<TenantRolePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  role: () => Promise<Role>;
}

export interface TenantRolePreviousValuesSubscription
  extends Promise<AsyncIterator<TenantRolePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  role: () => Promise<AsyncIterator<Role>>;
}

export interface TenantRoleSubscriptionPayload {
  mutation: MutationType;
  node: TenantRole;
  updatedFields: String[];
  previousValues: TenantRolePreviousValues;
}

export interface TenantRoleSubscriptionPayloadPromise
  extends Promise<TenantRoleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TenantRolePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TenantRolePreviousValuesPromise>() => T;
}

export interface TenantRoleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TenantRoleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TenantRoleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TenantRolePreviousValuesSubscription>() => T;
}

export interface TenantConnection {
  pageInfo: PageInfo;
  edges: TenantEdge[];
}

export interface TenantConnectionPromise
  extends Promise<TenantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TenantEdge>>() => T;
  aggregate: <T = AggregateTenantPromise>() => T;
}

export interface TenantConnectionSubscription
  extends Promise<AsyncIterator<TenantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TenantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTenantSubscription>() => T;
}

export interface ServiceSubscriptionPayload {
  mutation: MutationType;
  node: Service;
  updatedFields: String[];
  previousValues: ServicePreviousValues;
}

export interface ServiceSubscriptionPayloadPromise
  extends Promise<ServiceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ServicePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ServicePreviousValuesPromise>() => T;
}

export interface ServiceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ServiceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ServiceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ServicePreviousValuesSubscription>() => T;
}

export interface ServiceEdge {
  node: Service;
  cursor: String;
}

export interface ServiceEdgePromise extends Promise<ServiceEdge>, Fragmentable {
  node: <T = ServicePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ServiceEdgeSubscription
  extends Promise<AsyncIterator<ServiceEdge>>,
    Fragmentable {
  node: <T = ServiceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ServicePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  code: String;
  description?: String;
  status: String;
  type: String;
  version?: String;
  canBeRemoved: Boolean;
}

export interface ServicePreviousValuesPromise
  extends Promise<ServicePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  description: () => Promise<String>;
  status: () => Promise<String>;
  type: () => Promise<String>;
  version: () => Promise<String>;
  canBeRemoved: () => Promise<Boolean>;
}

export interface ServicePreviousValuesSubscription
  extends Promise<AsyncIterator<ServicePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  version: () => Promise<AsyncIterator<String>>;
  canBeRemoved: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateCustomerContact {
  count: Int;
}

export interface AggregateCustomerContactPromise
  extends Promise<AggregateCustomerContact>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerContactSubscription
  extends Promise<AsyncIterator<AggregateCustomerContact>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateArchitectureTier {
  count: Int;
}

export interface AggregateArchitectureTierPromise
  extends Promise<AggregateArchitectureTier>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateArchitectureTierSubscription
  extends Promise<AsyncIterator<AggregateArchitectureTier>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ComponentTemplateConnection {
  pageInfo: PageInfo;
  edges: ComponentTemplateEdge[];
}

export interface ComponentTemplateConnectionPromise
  extends Promise<ComponentTemplateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ComponentTemplateEdge>>() => T;
  aggregate: <T = AggregateComponentTemplatePromise>() => T;
}

export interface ComponentTemplateConnectionSubscription
  extends Promise<AsyncIterator<ComponentTemplateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ComponentTemplateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateComponentTemplateSubscription>() => T;
}

export interface TenantSubscriptionPayload {
  mutation: MutationType;
  node: Tenant;
  updatedFields: String[];
  previousValues: TenantPreviousValues;
}

export interface TenantSubscriptionPayloadPromise
  extends Promise<TenantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TenantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TenantPreviousValuesPromise>() => T;
}

export interface TenantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TenantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TenantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TenantPreviousValuesSubscription>() => T;
}

export interface ComponentTemplate {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  code: String;
}

export interface ComponentTemplatePromise
  extends Promise<ComponentTemplate>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  tier: <T = ArchitectureTierPromise>() => T;
}

export interface ComponentTemplateSubscription
  extends Promise<AsyncIterator<ComponentTemplate>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  tier: <T = ArchitectureTierSubscription>() => T;
}

export interface User {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  tenantRoles: <T = FragmentableArray<TenantRole>>(
    args?: {
      where?: TenantRoleWhereInput;
      orderBy?: TenantRoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  tenantRoles: <T = Promise<AsyncIterator<TenantRoleSubscription>>>(
    args?: {
      where?: TenantRoleWhereInput;
      orderBy?: TenantRoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface TenantAttributePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  parameter: String;
  value: String;
}

export interface TenantAttributePreviousValuesPromise
  extends Promise<TenantAttributePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  parameter: () => Promise<String>;
  value: () => Promise<String>;
}

export interface TenantAttributePreviousValuesSubscription
  extends Promise<AsyncIterator<TenantAttributePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  parameter: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface TenantAttributeSubscriptionPayload {
  mutation: MutationType;
  node: TenantAttribute;
  updatedFields: String[];
  previousValues: TenantAttributePreviousValues;
}

export interface TenantAttributeSubscriptionPayloadPromise
  extends Promise<TenantAttributeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TenantAttributePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TenantAttributePreviousValuesPromise>() => T;
}

export interface TenantAttributeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TenantAttributeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TenantAttributeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TenantAttributePreviousValuesSubscription>() => T;
}

export interface ArchitectureTierEdge {
  node: ArchitectureTier;
  cursor: String;
}

export interface ArchitectureTierEdgePromise
  extends Promise<ArchitectureTierEdge>,
    Fragmentable {
  node: <T = ArchitectureTierPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ArchitectureTierEdgeSubscription
  extends Promise<AsyncIterator<ArchitectureTierEdge>>,
    Fragmentable {
  node: <T = ArchitectureTierSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TenantPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
}

export interface TenantPreviousValuesPromise
  extends Promise<TenantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface TenantPreviousValuesSubscription
  extends Promise<AsyncIterator<TenantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface EnvironmentTenantConnection {
  pageInfo: PageInfo;
  edges: EnvironmentTenantEdge[];
}

export interface EnvironmentTenantConnectionPromise
  extends Promise<EnvironmentTenantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EnvironmentTenantEdge>>() => T;
  aggregate: <T = AggregateEnvironmentTenantPromise>() => T;
}

export interface EnvironmentTenantConnectionSubscription
  extends Promise<AsyncIterator<EnvironmentTenantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EnvironmentTenantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEnvironmentTenantSubscription>() => T;
}

export interface TenantAttributeEdge {
  node: TenantAttribute;
  cursor: String;
}

export interface TenantAttributeEdgePromise
  extends Promise<TenantAttributeEdge>,
    Fragmentable {
  node: <T = TenantAttributePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TenantAttributeEdgeSubscription
  extends Promise<AsyncIterator<TenantAttributeEdge>>,
    Fragmentable {
  node: <T = TenantAttributeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateComponentAttribute {
  count: Int;
}

export interface AggregateComponentAttributePromise
  extends Promise<AggregateComponentAttribute>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateComponentAttributeSubscription
  extends Promise<AsyncIterator<AggregateComponentAttribute>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomerEdge {
  node: Customer;
  cursor: String;
}

export interface CustomerEdgePromise
  extends Promise<CustomerEdge>,
    Fragmentable {
  node: <T = CustomerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerEdgeSubscription
  extends Promise<AsyncIterator<CustomerEdge>>,
    Fragmentable {
  node: <T = CustomerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "ArchitectureDefinition",
    embedded: false
  },
  {
    name: "ArchitectureTier",
    embedded: false
  },
  {
    name: "ArchitectureType",
    embedded: false
  },
  {
    name: "ComponentAttribute",
    embedded: false
  },
  {
    name: "ComponentInstance",
    embedded: false
  },
  {
    name: "ComponentTemplate",
    embedded: false
  },
  {
    name: "Customer",
    embedded: false
  },
  {
    name: "CustomerContact",
    embedded: false
  },
  {
    name: "Environment",
    embedded: false
  },
  {
    name: "EnvironmentTenant",
    embedded: false
  },
  {
    name: "ObjectAttributeType",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  },
  {
    name: "Service",
    embedded: false
  },
  {
    name: "Tenant",
    embedded: false
  },
  {
    name: "TenantAttribute",
    embedded: false
  },
  {
    name: "TenantRole",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
